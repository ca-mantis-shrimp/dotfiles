@document.meta
title: Entry
description: First and root files for the neovim configuration
authors: Darrion Burgess
categories: Neovim
created: 2025-07-25T19:12:38-0800
updated: 2025-07-30T23:33:03-0800
version: 1.1.1
@end
* Starting Init
  Our init file is primarily concerned with setting us up for success over the rest of the config and ensuring that we are ready for the rest of our plugins/config while being relatively minimal

** Source Config Files
   Before we do anything, we want to set the options for neovim itself by source the file at `config/options.lua` which we do with the following structure
   #tangle init.fnl
   @code fennel
   (require :config.options)
   @end

   We need to source this first because some options may be relevant for the rest of the config so we need to be sure we source it BEFORE the rest

** Bootstrapping {https://github.com/folke/lazy.nvim}[Lazy]
   One of, if not the most fundamental plugin is the plugin manage itself Lazy which is make by our resident savior folke, and can be seen as just a taste of the superior craftsmanship on display in the various plugins we will see throughout the entire system.

   lazy is wonderful because it is:
   - configuration centric, allowing a declarative plugin experience
   - powerful, allowing lazy loading of plugins to increase both stability and performance
   - polished so that we have an insane amount of love and structure including a TUI to view all of our other pieces

   We need to set this up properly and then we will be ready for the rest of our work as you can imagine, we need to setup the plugin manager before we can actually use the plugins properly 

   This will also define much of the rest of this config. Great lengths have been undertaken to stuff as much of the configuration of plugins in the lazy spec so that we can avoid scattering the configuration over multiple files.

   Sometimes its unavoidable but still we want to see as much in the spec as possible to give lazy the most leverage possible and making it possible to actually see everything the plugin needs in one go

*** get the standard lazy path
    we first have to deal with the problem of initial setup, how do we get lazy setup and get the rest setup before we actually start?

    The answer is that we just need to grab lazy dry and throw it in the right place 

    so first, we set a variable for the place where lazy should be located:
    #tangle init.fnl
    @code fennel
    (local lazypath (.. (_G.vim.fn.stdpath :data) :/lazy/lazy.nvim))
    @end
    ~ First, we get the "data" `:h standard-path` which is where config information should be stored and can differ by operating system
    ~ We append `/lazy/lazy.nvim` as that is the folder where lazy should reside if it doesnt already
    ~ we set this path to the `lazypath` variable for the various checks we will do in the following sections
*** Checking and Cloning Lazy
    Next we actually check of the folder at the path exists, and if not, we actually clone the repo down fresh with `git` and from there at the `lazypath` we set earlier 
    #tangle init.fnl
    @code fennel
    (when (not (_G.vim.loop.fs_stat lazypath))
      (let [lazyrepo "https://github.com/folke/lazy.nvim.git"]
        (_G.vim.fn.system [:git
        		   :clone
			   "--filter=blob:none"
    			   :--branch=stable
    			   lazyrepo
			   lazypath])))
    @end

    This is also a good showcase that neovim does have native ways to include 3rd party code, the benefits from lazy are more about making that situation easier and more declarative.

However still this is how we get the initial bootstrap done so that we can actually use lazy in the final part of this

*** Adding Lazy to the Runtime Path
    One design decision lazy makes is that it actually does NOT utilize the standard plugin directories, instead opting to use its own dedicated `lazy` folder as we saw above.

    However, in order to make lazy and the plugins using is capable, we need to add the lazy directory to the `:h rtp` which will enable neovim to use this like any other plugin:
    #tangle init.fnl
    @code fennel
    (_G.vim.opt.rtp:prepend lazypath)
    @end

*** Setting up Lazy
    With all the preludes out of the way, we are ready to setup Lazy as our first plugin properly

    #tangle init.fnl
    @code fennel
    (let [lazy (require :lazy)
            setup_opts {:spec [{:import :plugins}]}]
      (lazy.setup setup_opts))
    @end
    - now that lazy is downloaded and appended to the `rtp` we can require it like any other plugin
    - the only notable setting we use is that we import `plugins` which says we should automatically source any files in the `plugins/` directory of the config structure
    -- feel free to review `:h *lazy.nvim-⚙️-configuration*` for information on how to configure lazy itself

    Finally, we take the combination of the library and the config to actually setup lazy for the first time
    Important to note that this is the part of the config where the rest of the plugins are sourced, this means plugins will be imported, sourced, and setup before the rest of the config is run which is relevant as future files may assume plugins have been setup by the time they run

** Sourcing Post-Plugin files
   Now that the plugins have been sourced and setup, we can run the last few lines to source files that may _leverage_ these plugins

   Again, order matters here
   #tangle init.fnl
   @code fennel
   (require :config.keymaps)
   (require :config.autocmds)
   @end
   - the source file with keymaps may have plugin-specific keymaps which is why it must come after plugin setup
   -- in addition to keymaps for OOTB functionality, this is also where we put hotkeys that COULDNT be setup before the plugin was setup which should be relatively rare
   - Same with the autocommand, we may be utilizing plugin functionality so we can setup autocommands for plugins when necessary

