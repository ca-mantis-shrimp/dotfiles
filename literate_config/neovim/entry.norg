@document.meta
title: Entry
description: First and root files for the neovim configuration
authors: Darrion Burgess
categories: Neovim
tangle: ../../dot_config/remove_nvim/lua/init.fnl
created: 2025-07-25T19:12:38-0800
updated: 2025-12-27T16:41:36-0800
version: 1.1.1
@end

* Working with Neovim Literate Config

  *For general literate config guidance (workflow, architecture), see `{:$/architecture:}[architecture.norg]`.*

  This section covers neovim-specific details.

** Neovim-specific workflow
   Neovim configs have an extended pipeline due to Fennel compilation:

   @code
   1. Edit:    literate_config/neovim/**/*.norg
   2. Tangle:  → dot_config/remove_nvim/lua/**/*.fnl (Neorg extracts code)
   3. Compile: → dot_config/remove_nvim/lua/**/*.lua (nfnl compiles fennel)
   4. Format:  → (conform formats lua to prevent chezmoi `{{` conflicts)
   5. Apply:   → ~/.config/nvim/lua/**/*.lua (chezmoi deploys)
   @end

   See `config/literate_workflow.norg` for automation that collapses steps 2-5.

** Where to find things
   - *Formatters* → `plugins/platforms/conform.norg`
   - *LSP* → Check `plugins/platforms/` for LSP configs
   - *Keybindings* → `config/keymaps.norg`
   - *Autocommands* → `config/autocmds.norg`
   - *Options* → `config/options.norg`
   - *Workflow automation* → `config/literate_workflow.norg`
   - *Plugin specs* → `plugins/[category]/[name].norg`

** Neovim-specific tools
   - `:ConformInfo` - Check formatter status, errors, log
   - `:LspInfo`, `:LspLog` - LSP diagnostics
   - `:checkhealth [plugin]` - Plugin health checks
   - `:lua vim.loader.reset()` - Reset module cache (fixes "module not found")
   - `:Telescope keymaps` - Browse all keybindings

** Neovim-specific gotchas
   - *Module cache:* New lua modules need `:lua vim.loader.reset()` or neovim restart
   - *Formatters are system packages:* Install via pacman, not through neovim
   - *Load order:* Plugins load before config files (see sourcing order at end of this file)

* A note on tangling
  one very important note is that while we are tangling fennel files, the real flow for changing the config is this:
  ~ Tangle the new fennel file directly to the chezmoi source directory (`dot_config/remove_nvim/`)
  ~ The fennel file gets compiled to lua via nfnl (triggered by save hook)
  ~ The lua file gets formatted via conform (triggered by save hook)
  ~ Run `chezmoi apply` to sync to `~/.config/nvim/`
  ~ Or use `:TangleAndApply` to automate all steps

* A note on module loading
  Neovim caches lua module locations for performance. When adding new lua modules or moving files, the cache may not reflect the changes until neovim is restarted.

  *Quick fix:* Run `:lua vim.loader.reset()` to rebuild the cache without restarting.

  This is particularly relevant when working with the literate config - after tangling and compiling new modules, they may not be immediately `require()`-able until the cache is reset or neovim is restarted.

* Starting Init
  Our init file is primarily concerned with setting us up for success over the rest of the config and ensuring that we are ready for the rest of our plugins/config while being relatively minimal

** Source Config Files
   Before we do anything, we want to set the options for neovim itself by source the file at `config/options.lua` which we do with the following structure

   we also source some utlity functions that we will use throughout the rest of the config such as the treesitter setup function
   #tangle
   @code fennel
   (require :config.options)
   (require :config.utils)
   @end

   We need to source this first because some options may be relevant for the rest of the config so we need to be sure we source it BEFORE the rest

** Literate Config Tooling
   We load our custom tooling for working with the literate config itself.
   This needs to come early so it's available in all norg buffers.
   #tangle
   @code fennel
   (require :config.literate_inspector)
   @end

** Bootstrapping {https://github.com/folke/lazy.nvim}[Lazy]
   One of, if not the most fundamental plugin is the plugin manage itself Lazy which is make by our resident savior folke, and can be seen as just a taste of the superior craftsmanship on display in the various plugins we will see throughout the entire system.

   lazy is wonderful because it is:
   - configuration centric, allowing a declarative plugin experience
   - powerful, allowing lazy loading of plugins to increase both stability and performance
   - polished so that we have an insane amount of love and structure including a TUI to view all of our other pieces

   We need to set this up properly and then we will be ready for the rest of our work as you can imagine, we need to setup the plugin manager before we can actually use the plugins properly 

   This will also define much of the rest of this config. Great lengths have been undertaken to stuff as much of the configuration of plugins in the lazy spec so that we can avoid scattering the configuration over multiple files.

   Sometimes its unavoidable but still we want to see as much in the spec as possible to give lazy the most leverage possible and making it possible to actually see everything the plugin needs in one go

*** get the standard lazy path
    we first have to deal with the problem of initial setup, how do we get lazy setup and get the rest setup before we actually start?

    The answer is that we just need to grab lazy dry and throw it in the right place 

    so first, we set a variable for the place where lazy should be located:
    #tangle
    @code fennel
    (local lazypath (.. (_G.vim.fn.stdpath :data) :/lazy/lazy.nvim))
    @end
    ~ First, we get the "data" `:h standard-path` which is where config information should be stored and can differ by operating system
    ~ We append `/lazy/lazy.nvim` as that is the folder where lazy should reside if it doesnt already
    ~ we set this path to the `lazypath` variable for the various checks we will do in the following sections
*** Checking and Cloning Lazy
    Next we actually check of the folder at the path exists, and if not, we actually clone the repo down fresh with `git` and from there at the `lazypath` we set earlier 
    #tangle
    @code fennel
    (when (not (_G.vim.loop.fs_stat lazypath))
      (let [lazyrepo "https://github.com/folke/lazy.nvim.git"]
        (_G.vim.fn.system [:git
                           :clone
                           "--filter=blob:none"
                           :--branch=stable
                           lazyrepo
                           lazypath])))
    @end

    This is also a good showcase that neovim does have native ways to include 3rd party code, the benefits from lazy are more about making that situation easier and more declarative.

However still this is how we get the initial bootstrap done so that we can actually use lazy in the final part of this

*** Adding Lazy to the Runtime Path
    One design decision lazy makes is that it actually does NOT utilize the standard plugin directories, instead opting to use its own dedicated `lazy` folder as we saw above.

    However, in order to make lazy and the plugins using is capable, we need to add the lazy directory to the `:h rtp` which will enable neovim to use this like any other plugin:
    #tangle
    @code fennel
    (_G.vim.opt.rtp:prepend lazypath)
    @end

*** Setting up Lazy
    With all the preludes out of the way, we are ready to setup Lazy as our first plugin properly

   #tangle
    @code fennel
    (let [lazy (require :lazy)
          setup_opts {:spec [{:import :plugins}]
                      :dev {:path "~/Products" :patterns [:tree-sitter-actions]}}]
      (lazy.setup setup_opts))
    @end
    - now that lazy is downloaded and appended to the `rtp` we can require it like any other plugin
    - we import `plugins` which says we should automatically source any files in the `plugins/` directory of the config structure
    - the `:dev` configuration enables seamless development/production switching:
    -- `:path` sets the directory where local plugin development happens (~/Products)
    -- `:patterns` specifies which plugins to load from the local path when available
    -- when `~/Products/tree-sitter-actions` exists, lazy uses that version (development machines)
    -- when it doesn't exist, lazy falls back to cloning from GitHub (production/user machines)
    -- this allows one config to work across all machines without modification
    -- feel free to review `:h *lazy.nvim-⚙️-configuration*` for information on how to configure lazy itself

    Finally, we take the combination of the library and the config to actually setup lazy for the first time
    Important to note that this is the part of the config where the rest of the plugins are sourced, this means plugins will be imported, sourced, and setup before the rest of the config is run which is relevant as future files may assume plugins have been setup by the time they run

** Sourcing Post-Plugin files
   Now that the plugins have been sourced and setup, we can run the last few lines to source files that may _leverage_ these plugins

   Again, order matters here
   #tangle
   @code fennel
   (require :config.keymaps)
   (require :config.autocmds)
   (require :config.literate_workflow)
   @end
   - the source file with keymaps may have plugin-specific keymaps which is why it must come after plugin setup
   -- in addition to keymaps for OOTB functionality, this is also where we put hotkeys that COULDNT be setup before the plugin was setup which should be relatively rare
   - Same with the autocommand, we may be utilizing plugin functionality so we can setup autocommands for plugins when necessary
   - literate_workflow depends on neorg, nfnl, and conform so it must come after plugin setup

