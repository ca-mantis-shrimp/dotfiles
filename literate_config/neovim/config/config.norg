@document.meta
title: Neovim Config
description: Config File for configuring the Options of Neovim Itself
authors: Darrion Burgess
categories: Neovim Config
created: 2025-07-26T23:48:23-0800
updated: 2025-07-28T23:11:12-0800
version: 1.1.1
@end
Configuration is an interesting topic in Neovim because there are just so many ways to approach it.

but for now, what we have settled on is a single fennel file that will just get the config out of the way early this way we can work through the structures and update them all in one place before the structure is built

* Options
  Remember, you can look up the documentation for any of these options within the editor itself by doing `:h <option>`

  Within lua, we have this convenient dictionary of options called `opt` that we can use as a frontend to configure these options quickly while still having the full power of the language at our disposal
** Core Functionality
   At its core, we have some quick options that enable functionality or configure how the application itself works which is more fundamental
*** Running directory-local scripts
    This is nice because it allows:
    - project-specific configuration
    - the ability to define custom `make` and keymaps that are relevant for only a single project
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.exrc true)
    @end
*** Automatically changing directory
    Another surprisingly impactful option is the `autochdir` option which actually change the `pwd` of neovim to whatever directory contains the buffer we are editing

    I keep going back-and-forth on whether or not to keep this on as it makes for a strange workflow

    this can run into problems if we are in a deep directory, as many programs assumethe `pwd` is the root directory of the project.

    however, this aleviates the need to manually manage the directory of the `pwd` as this is now coupled to the buffer we are currently editing, making a whole range of software easier to manage as most are able to be smart about it and look for the git file in the parent directory(s)

    Still, it causes just as much friction as it eliminates at times so this is something i keep an eye on
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.autochdir true)
    @end
*** Enabling the mouse
    As much as it is considered sacreligous in our community, I do enable the `mouse` for all modes as it can sometimes be helpful in cases like moving window splits manually when i dont feel like doing it with the hotkey

    no harm in making it do something even if it isnt central for us
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.mouse :a)
    @end
*** Disabling the tutorial content
    `showmode` is cute little tutorial that allows users to more clearly see when they are in insert vs visual mode.

    but we dont need this so i think i prefer to keep the screen real estate clean
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.showmode false)
    @end
*** Leveraging the undofile
    by default, neovim loses the undo history for your buffers, but with `undofile` enabled, we can start to experience `undo-persistence` where the undo history is maintained over time and saved to the filesystem
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.undofile true)
    @end
*** Periodically saving buffers
    by default the swap file doesnt save while we arent doing anything, leading to the risk that we lose our work if a power outage goes out or we otherwise close the editor after some time

    we set the time interval to 250 which is the amount of miliseconds it will wait while getting no input before it saves the current state to a swap file, just in case
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.updatetime 250)
    @end

*** Adding Extra Filetypes
    we use `vim.filetype` to quickly add some filetype detection
    #tangle options.fnl
    @code fennel
    (_G.vim.filetype.add {:extension {:http :http}})
    @end
** Hotkeys
   As a keyboard-driven editor, one of the core mechanics that need to be configured is the hotkey functionality
*** Leader Key
    One core concept in Neovim is the concept of the `:h leader` key, which can be thought of as a holding zone for custom hotkeys.

    neovim already has quite a few hotkeys, and it can be hard to find space for your own hotkeys without overwriting existing funtionality.

    To make things easy, we can just handle this through the use of the leader key

    local leader is intended for buffer-specific hotkeys so this is a good place to put stuff that is set from the `.nvim.lua` file or other proct-specific or filetype-specific hotkeys

    whereas leader is more meant for the entire codebase and stuff that is relevant at all times
    #tangle options.fnl
    @code fennel
    (set _G.vim.g.mapleader " ")
    (set _G.vim.g.maplocalleader ",")
    @end
    - leader is set to `<space>` as is the community default
    - localleader is `,` which is pretty barren for now
** Search and Replace
   Neovim has sophisticated find and replace functionality which we can quickly configure
*** Customizing Searching
    When we do a search with `/` we can configure the searching patterns

    `ingorecase` makes it so that we can type either lowercase or uppercase and it will find both variants when we search files
    `smarcase` further refines this by then making it so this rule only applys when our search term contains lowercase letters, if we want something with an upper case letter, it will search that specifically, allowing us to again get closer to having our cake and allowing us to eat it too, at the cost of internal complexity
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.ignorecase true)
    (set _G.vim.opt.smartcase true)
    @end
*** Customizing substitutions for live preview
    `inccommand` allows us to use the pattern-based replacement logic so we can see a preview of the replacements BEFORE we apply it, and with the "split" option, it is shown in a small split
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.inccommand :split)
    @end
*** highlighting search targets
    when we search with `/` we can see what would be found in a dynamic highlight group by enabling the `hlsearch` option
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.hlsearch true)
    @end
** Customize hotkey times
   many hotkeys have more than one key so we have the problem of how long do we wait between the initial hotkey and the next hotkey? we can set that duration with `timeoutlen` i find 300 miliseconds is a good amount of time where if i actually didnt want to click that hotkey i can just let it expire.

   otherwise, you have to actually escape the whole thing which can get tedius

   #tangle options.fnl
   @code fennel
   (set _G.vim.opt.timeoutlen 300)
   @end
** GUI Options
   One awesome piece of functionality for vim is that the server is separate from the TUI, meaning we can move neovim to run in a GUI environment!

   However, some of the setting dont transition over so we have to set gui-specific settings to make it easier to work
   #tangle options.fnl
   @code fennel
   (set _G.vim.g.neovide_scale_factor 1.0)
   @end
** Formatting
   Formatting is an interesting topic. we can set the program used for formatting using `formatexpr`

   Now, this is our only time of referencing a plugin, in this case we are referencing the function available from {https://github.com/stevearc/conform.nvim}[conform.nvim] but importantly, this will only work after we require the conform plugin
   #tangle options.fnl
   @code fennel
   (set _G.vim.opt.formatexpr "require'conform'.formatexpr()")
   @end
** {https://microsoft.github.io/language-server-protocol/}[Language Server Protocol](LSP) in Neovim
   Neovim has native support for LSP, so we can setup the LSP servers for these various languages and here we go ahead and setup the LSP servers listed.
*** LSP Server Setup

    This either goes either from the {https://github.com/neovim/nvim-lspconfig}[lspconfig] configuration settings
    or stuff that we setup by hand in `lsp`

    Now, do note that this is the list of SERVERS we are setting up, not the list of languages so it can be confusing 
    #tangle options.fnl
    @code fennel
    (_G.vim.lsp.enable [:lua_ls
    :fennel_language_server
    :pyright
    :fish-lsp
    :systemd_ls
    :powershell_es
    :jsonls
    :clojure_lsp
    :rust_analyzer])
    @end
    Here is a breakdown of how they translate to structured languages
    @table
   |server|language(s)|
   |lua_ls|lua|
   |pyright|python|
   |fish-lsp|fish|
   |systemd_ls|systemd conf|
   |jsonls|json|
   |clojure|lsp|clojure|
   |rust_analyzer|rust|
    @end
*** LSP Diagnostic Config
    Now neovim has a native system for getting diagnostics about the current buffer. now, this is mostly meant for LSP, but we are seeing more interesting work here to put good new information in like the formatting or the other structures
    #tangle options.fnl
    @code fennel
    (_G.vim.diagnostic.config {:virtual_text {:current_line true}
    :virtual_lines true})
    @end
** UI
*** Default Floating Window Border
    Now that we are working through the UI elements, we can decide the default type of border to use and for now we default to rounded
    #tangle options.fnl
    @code fennel
    (set _G.vim.o.winborder :rounded)
    @end
*** Customizing Window Placement
    when creating a new window we need a default location, both horizonally and vertically.

    so we default to right for horizontal, and down for vertical as we are usually creating a secondary window so that should go on the less dominant side of the screen is my view
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.splitright true)
    (set _G.vim.opt.splitbelow true)
    @end
*** Customizing whitespace characters
    in programming we have to be precise in our use of whitespace, we need to care about the difference between a tab and a space and a trailing whitespace

    to this end, we have the `list` option to _list_ these whitespace characters and we further customize them using `listchars` to make WHAT we are seeing custom
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.list true)
    (set _G.vim.opt.listchars {:tab "» " :trail "·" :nbsp "␣"})
    @end
*** Enabling the signs on the side
    one popular new mechanic is putting cute little icons on the left, this area for icons is called the `signcolumn` which can be ofcourse customized 
    This includes stuff like:
    - git status
    - LSP diagnostics
    - LSP actions

    we set this to 'yes' so that we always have the sign column at the default length of 1 character
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.signcolumn :yes)
    @end
*** Highlighting Cursor Line
    in order to make finding the cursor easy, we can enable `cursorline` to highlight the line our cursor resides in to make it easier to find

    In addition, `scrolloff` helps by ensuring 10 lines are viewable below and above the cursor. Otherwise, scrolling feels awkward as you go and make a scrolling motion and only see the bottom line, this makes sure that even as you scroll a good portion of the file is viewable
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.cursorline true)
    (set _G.vim.opt.scrolloff 10)
    @end
*** Visually maintain indentation for wrapped lines
    line wrapping is a funny topic with a few options available.

    we use `breakindent` to actually work with wrapped lines by showing as slightly indented lines below the first line. Its just a single space, but it helps to visually tell when what looks like a paragraph is actually a very long line
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.breakindent true)
    @end
*** Line Numbers
    For our line numbers, I like a strange combination but it makes sense

    this comes from mixing two different options:
    `number` shows the _absolute_ line number we are on, so the actual line of the file

    while `relativenumber` ensures that the lines are actually their _relative_ position to your cursor, so the line above and below will be "1" as they are 1 away from your cursor

    when both are put together your cursor shows the _absolute_ line you are on, while still showing the _relative_ numbers around it 
    This is awesome for something like neovim where we often need to move some relative number of lines over and now we dont even need to calculate anything we can just see what the number of lines we need to move is 
    #tangle options.fnl
    @code fennel
    (set _G.vim.opt.number true)
    (set _G.vim.opt.relativenumber true)
    @end
*** Using {https://www.nerdfonts.com/}[Nerd Fonts]
    We can leverage fonts that have nerdfont customizations with the following switch

    Any plugins and options that have nerdfont option will use this to  get us those sweet icons
    #tangle options.fnl
    @code fennel
    (set _G.vim.g.have_nerd_font true)
    @end

* Hotkeys
  as a keyboard-driven editor we want to structure the work so that we are able to break it out and make it easy to understand

  for this work, we want to actually work out the keymaps that will be critical to the construction of our work
** {https://github.com/folke/which-key.nvim}[whichkey]
   for our work, we need to go ahead and use which-key to get not only the keymaps done in a declarative way, but to make it accessible within the UI of whichkey 
*** Groups 
    We can put the hotkeys under groups so we do that up-front

    the hope is the [s] is for searching things, [t] is for the testing stuff, and [N] is for neorg-related hotkeys
    #tangle keymaps.fnl
    @code fennel
    (let [wk (require :which-key)]
    (wk.add [{1 :<leader>u :group "[u]i"}
    {1 :<leader>s :group "[s]earch"}
    {1 :<leader>t :group "[t]est"}
    {1 :<leader>n :group "[N]eorg"}
    {1 :<leader><tab> :group "[tab]s"}
    {1 :<leader>i :group "[I]ntentions"}
    @end
*** {https://github.com/ClearHeadToDo-Devs/clearhead-cli}[cliche] hotkeys!
    our very own CLI designed to handle the intricacies of editing the proper editor
    #tangle keymaps.fnl
    @code fennel
    {1 :<leader>ie
    2 #(_G.vim.cmd.edit {:args [(.. (_G.vim.fn.fnamemodify (_G.vim.fn.stdpath :data)
    ":h")
    :/clhd/active.actions)]})
    :desc "Edit clearhead actions file"}
    @end
*** Tab-Management
    we manage the `tab` mechanic through the `<tab>` key
    #tangle keymaps.fnl
    @code fennel
    {1 :<leader><tab><tab> 2 :<cmd>tabnew<CR> :desc "Create New [tab]"}
    {1 :<leader><tab><Del>
    2 :<cmd>tabclose<CR>
    :desc "[Del]ete Current Tab"}
    {1 :<leader><tab>n 2 :<cmd>tabNext<CR> :desc "[n]ext Tab"}
    {1 :<leader><tab>p 2 :<cmd>tabprevious<CR> :desc "[p]revious Tab"}
    {1 :<leader><tab>r
    2 "<cmd>tcd -<CR>"
    :desc "CD to previous directory in current tab"}
    @end
    - we create a new tab with two clicks of `<tab>`
    - add `<del>` and we will delete the tab
    - in the spirit of vim navigation we use `n` and `p` to iterate through tabs
    - `r` returns to the previous `pwd` for the current `tabpage`
*** Git
    now this is just a little hotkey to do some git hunks work in visual mode
    #tangle keymaps.fnl
    @code fennel
    {1 :<leader>h :desc "Git [H]unk" :mode :v}
    @end
*** escape from sub modes
    just some stuff to use `<esc>` to escape (pun-intended) one of the submodes
    - either the highlights from our previous search
    - or the terminal mode from one of our sub terminals
    #tangle keymaps.fnl
    @code fennel
    {1 :<Esc>
    2 :<cmd>nohlsearch<CR>
    :desc "Remove Search Highlighting on Escape"}
    {1 :<Esc><Esc>
    2 "<C-\\><C-n>"
    :mode :t
    :desc "[Esc]ape terminal mode"}
    @end
*** Diagnostic Hotkeys
    Hotkeys for managing diagnostic messages to make working and iterating through diagnostic info nice
    #tangle keymaps.fnl
    @code fennel
    {1 "[d"
    2 #(_G.vim.diagnostic.goto_prev)
    :desc "Go to previous [D]iagnostic message"}
    {1 "]d"
    2 #(_G.vim.diagnostic.goto_next)
    :desc "Go to next [D]iagnostic message"}
    {1 :<leader>q
    2 #(_G.vim.diagnostic.setloclist)
    :desc "Open diagnostic [Q]uickfix list"}
    @end
*** Lazy and Noice
    Some of the more interesting plugins include the built-in ui of our package manager {https://github.com/folke/lazy.nvim}[lazy.nvim]

    as well as managing the extra functionality from {https://github.com/folke/noice.nvim}[noice.nvim]
    #tangle keymaps.fnl
    @code fennel
    {1 :<leader>un
    2 :<cmd>NoiceDismiss<cr>
    :desc "Dismiss All Notifications"}
    {1 :<leader>l 2 :<cmd>Lazy<CR> :desc "Start Lazy"}]))
    @end

** Window hotkeys
   we just have a few hotkeys to make navigation of windows so easy that we just move over by a nice `<hjkl>` format without the W

   We also add our hotkey to save the buffer

   This is nice because we cant really do stuff like this with which key, or atleast there isnt much point to it so we just define them with the OOTB `keymap.set` function from the `keymap` api
   #tangle keymaps.fnl
   @code fennel
   (_G.vim.keymap.set :n :<C-h> :<C-w><C-h>
   {:desc "Move focus to the left window"})

   (_G.vim.keymap.set :n :<C-l> :<C-w><C-l>
   {:desc "Move focus to the right window"})

   (_G.vim.keymap.set :n :<C-j> :<C-w><C-j>
   {:desc "Move focus to the lower window"})

   (_G.vim.keymap.set :n :<C-k> :<C-w><C-k>
   {:desc "Move focus to the upper window"})
   (_G.vim.keymap.set :n :<C-s> :<cmd>w<CR> {:desc "Save current Buffer"})
   @end

** GUI Hotkeys
   GUI commands need their own hotkeys, we have some points but there is not really allot of change
   #tangle keymaps.fnl
   @code fennel
   (fn change-scale-factor [delta]
   (set _G.vim.g.neovide_scale_factor (* _G.vim.g.neovide_scale_factor delta)))
   (_G.vim.keymap.set :n :<C-=> #(change-scale-factor 1.25))
   (_G.vim.keymap.set :n :<C--> #(change-scale-factor (/ 1 1.25)))
   (_G.vim.keymap.set :n "<C-[>" #(set _G.vim.g.neovide_scale_factor 1.0))
   @end
   ~ First , we set a function that allows us to change the scale factor from the original one we set in `options.fnl`
   ~ Then, we use that function in our work to do the zooming functionality we want these just take away the need for shift where most of these need like the usual `+` for zooming in
   ~~ `=` for zooming out
   ~~ `-` for zooming in
   ~~ `[` to put it back to default
   ~ finally we just have to make a separate 
* Autocommands
  `autocmd` is a powerful api that lets us hook into various pieces of Neovim to extend or otherwise change it dynamically at runtime based on certain conditions.

  But they are also very brittle and easy to mess up so absolute discipline is necessary and if you can do it without an autocommand then you should try
** Highlight Yanks before yanking them
   just to add a bit of visual feedback we add a quick highlight right before we yank something so we can visually see what we grabbed
   #tangle autocmds.fnl
   @code fennel
   (_G.vim.api.nvim_create_autocmd :TextYankPost
   {:desc "highlight when yanking text"
   :group (_G.vim.api.nvim_create_augroup :kickstart-highlight-yank
   {:clear true})
   :callback (fn []
   (_G.vim.highlight.on_yank))})
   @end
** Setup LSP-related plugins after initial startup
   since lsp hotkeys can only be setup AFTER the lsp is actually attached, this is best done as an autocommand to get this done for all languages with an LSP while no polluting the keymaps for languages where its unnecesary

*** LSP Callback
    the work itself is a function that is called after the proper trigger event
    here we are actually going to be working with a few hotkey types so to go over them:
    most of them reside behind `<leader>`
    - `rn` [r]e[n]ames the variable
    - `ca` brings up the [c]ode [a]ction options
    - `K` allows for hover documentation
    -- so fundamental we keep it under homerow even if it doesnt make as much phonetic sense and `K` is the traditional documentation hotkey
    - `gD` [g]oes to [D]eclaration
    - `th` [t]oggles inlay [h]ints

    we also create a few autocommands to:
    - highlight all instances of a variable that our cursor is hovering over
    -- and stop when we move cursor 
    #tangle autocmds.fnl
    @code fennel
    (fn setup_lsp [event]
    (local setup_lsp_map
    (fn [keys func desc]
    (_G.vim.keymap.set :n keys func
    {:buffer event.buf :desc (.. "LSP: " desc)})))
    (setup_lsp_map :<leader>rn _G.vim.lsp.buf.rename "[R]e[n]ame")
    (setup_lsp_map :<leader>ca _G.vim.lsp.buf.code_action "[C]ode [A]ction")
    (setup_lsp_map :K _G.vim.lsp.buf.hover "Hover Documentation")
    (setup_lsp_map :gD _G.vim.lsp.buf.declaration "[G]oto [D]eclaration")
    (local client (_G.vim.lsp.get_client_by_id event.data.client_id))
    (when (and client client.server_capabilities.documentHighlightProvider)
    (_G.vim.api.nvim_create_autocmd [:CursorHold :CursorHoldI]
    {:buffer event.buf
    :callback _G.vim.lsp.buf.document_highlight})
    (_G.vim.api.nvim_create_autocmd [:CursorMoved :CursorMovedI]
    {:buffer event.buf
    :callback _G.vim.lsp.buf.clear_references}))
    (when (and client client.server_capabilities.inlayHintProvider
    _G.vim.lsp.inlay_hint)
    (setup_lsp_map :<leader>th
    (fn []
    (_G.vim.lsp.inlay_hint.enable 0
    (not (_G.vim.lsp.inlay_hint.is_enabled))))
    "[T]oggle Inlay [H]ints")))
    @end
*** Creating the autocommand
    all we do now is run the function above from the `LspAttach` event.

    I will also note this is part of the `lsp-attach` autocommand group to denote this is meant to be done after we have attached an lsp server
    #tangle autocmds.fnl
    @code fennel
    (_G.vim.api.nvim_create_autocmd :LspAttach
    {:group (_G.vim.api.nvim_create_augroup :lsp-attach
    {:clear true})
    :callback setup_lsp})
    @end
