@document.meta
title: index
description: 
authors: root
categories: 
created: 2023-04-07
updated: 2023-04-14
version: 1.0.0
@end
Plugins are what really makes Neovim special, and here we can explore the magic (and frustration) of using plugins created for Neovim by the community

I think to start, I am just going to start with the smaller stuff and then work through it one at a time. Especially large plugins will likely get their own file so I can decouple them from what I have to do with the others which can be generated all at once
* {:completion:}[Completion Configuration]
* {:neorg:}[Neorg configuration]
* Toggle Term
  Firsfirst we have the excellent {https://github.com/akinsho/toggleterm.nvim/tree/b86982429325112d2b20c6d0cc7a5c4b182ab706}[toggleterm.nvim] plugin that can be used to facilitate a workflow where I occasionally _toggle_ a terminal page, do some actions, and leave

  The snippet for enabling this is even easy:
  #tangle toggleTerm.lua
  @code lua
  return {
    "akinsho/toggleterm.nvim",
    version = "*",
    opts = {
      open_mapping = [[<a-\>]],
      direction = 'float',
    },
  }
  @end
  - The version piece here is just going to grab the latest standard version
  -- This works because toggleterm follows SemVer
  - Otherwise, we just have to set the hotkey to _toggle_ the terminal on and off.
  -- Here we are using the standard `<a-\>` function to enable or disable the terminal itself
  --- This is a kinda nice hotkey because it works outside and inside of the terminal, whereas normal hotkeys don't work in a terminal because it is basically always in insert mode
  - we also opted to do a float rather than a split for our terminal because often times we are just looking to shift our focus for a second, run some commands, and return
  -- This isn't like VSCode where you just keep the termial open all the time just cause it opens that way and you feel you need to
* Portal Configuration
  Portal is an interesting little plugin that enables us to visualize the jumplist before you just jump there.
  #tangle portal.lua
  @code lua
  return {
    "cbochs/portal.nvim",
    dependencies = { "cbochs/grapple.nvim" },
    keys = {
      { "<leader>o", "<cmd>Portal jumplist backward<cr>" },
      { "<leader>i", "<cmd>Portal jumplist forward<cr>" },
    },
  }
  @end
  - {https://github.com/cbochs/grapple.nvim/tree/ab274a3bfb674442d57fca05df866b71895853bc}[grapple.nvim] serves as the core library that allows for this file list and enable the preview capabilities
  - Otherwise, the plugin is only loaded when you use either of the keybinds above
  -- we chose `<leader>`o and i because it mirrors the normal jumplist hotkeys to express that they are paralell but different features
* Noice
  {https://github.com/folke/noice.nvim}[noice.nvim] is a super interesting, experimental plugin that was made by our resident hero folke.

  This plugin does many things, but chief among them is:
  - Introduction of great notifications via noice.nvim
  - Replacing command lines with a new popup format
  - and a bunch of other little things that make neovim really feel like an editor from the twenty first century

  #tangle noice.lua
  @code lua
  return {
    "folke/noice.nvim",
    cond = not vim.g.started_by_firenvim,
  }
  @end
* LSP Lines
  By Default, LSP diagnostics are displayed as virtual text at the end of the line
  Virtual Text is the text that is made outside of the buffer and can move to stick to a specific line rather than being present in the buffer
  - However, this makes it dificult to read all bust the most succinct warnings/errors
  - doubly-so for the case where we have multiple diagnostics/errors to review

  {https://github.com/ErichDonGubler/lsp_lines.nvim/tree/3b57922d2d79762e6baedaf9d66d8ba71f822816}[lsp_lines.nvim] attempts to fix this issue by replacing the default virtual text solution with one where instead each diagnostic gets its own line (hence the name) so multiple/long diagnostic messages can be shown without issue
  #tangle lspLines.lua
  @code lua
  return {
    "ErichDonGubler/lsp_lines.nvim",
    dependencies = { "neovim/nvim-lspconfig" },
    config = function()
      vim.diagnostic.config({
        virtual_text = false,
      })
      require("lsp_lines").setup()
    end,
    ft = { "lua", "python", "rust" },
  }
  @end
  - First, we need to ensure this is loaded after lspconfig since this relies on the configuration for this.
  - we have to use the functional way of setting up the plugin because we need to make a small change first
  -- The thing we need to do is disable the default virtual_text solution for diagnostics in Neovim
  --- if we dont, this will result in duplicate diagnostic messages when we are editing code
  --- afterwards, we can setup the plugin like normal
  - Finally, we need to restrict the filetypes that we enable lsp_lines on because otherwise we get annoying duplication in things like the lazy floating window
* Git Diff
  The standard diff view for Neovim is fine, but it leaves a few things to be desired.
  - It doesn't feel like a really integrated solution with the ability to show the context
  - More importantly, it can't show multiple files easily making the process of reviewing diffs for multiple files (as if often the case when we do `chezmoi apply`), then it can make the process feel cumbersome
  #tangle gitDiff.lua
  @code lua
  return {
    { "sindrets/diffview.nvim", dependencies = "nvim-lua/plenary.nvim" },
  }
  @end
* Chezmoi Support
  Chezmoi has a bunch of strange files so this (rather old) plugin justt ries to smooth over the rough edges by properly highlighting these files and whatnot.
  #tangle chezmoi.lua
  @code lua
  return {
    "alker0/chezmoi.vim",
  }
  @end
* Testing
  We are using a very exciting framework called {https://github.com/nvim-neotest/neotest}[neotest] where we can to do testing within neovim itself.
  It is a testing framework that is applicable to most languages so we can just setup a new configuration for each filetype
  In addition, it adds a bunch of UI elements that make the experience better using Neovim's newest UI improvements
** Keymaps
   This is one of those plugins we want to put behind lazy loading until we need it so most of the plugins can be used to load the plugin as well as running the function itself
   #tangle neotest.lua
   @code lua
   local activation_hotkeys = {
     {
       "<leader>tS",
       function()
         require("neotest").summary.toggle()
       end,
       desc = "Toggle Neotest Summary",
     },
     {
       "<leader>tr",
       function()
         require("neotest").run.run()
       end,
       desc = "Run Nearest Test",
     },

     {
       "<leader>tf",
       function()
         require("neotest").run.run(vim.fn.expand("%"))
       end,
       desc = "Run Current File",
     },

     {
       "<leader>ts",
       function()
         require("neotest").run.run(vim.fn.getcwd())
       end,
       desc = "Run Test Suite",
     },
   }

   @end
   ~ Neotest includes a fancy test summary page that is able to visualize the file structure of your project and show not only the list of tests in each file but their actual test state! This hotkey toggles said summary
   ~~ Do note, We need to run the test suite BEFORE we can see the results within this fancy summary
   ~ Run Nearest Test to Cursor
   ~~ Useful for debugging during TDD which is why it's the first actual test
   ~~ While some languages have trouble running a full test suite, running a single test is almost always fine.
   ~ This one is for testing the entire file, useful if the test suite is big and slow
   ~~ that snippet `vim.fn.expand('%')` will return the name of the current buffer since this is the special character for the current buffer
   ~ Finally we have the test suite hotkey which will test the full test suite.
   ~~ While we want this to be our main hotkey, it is also the one more prone to breaking since the concept of a test suite and what is contained within varies between languages
** Dependencies
   #tangle neotest.lua
   @code lua
   local dependencies_list = {
     "nvim-lua/plenary.nvim",
     "nvim-treesitter/nvim-treesitter",
     "antoinemadec/FixCursorHold.nvim",
     "rouge8/neotest-rust",
     "nvim-neotest/neotest-python",
   }
   @end
   - Plenary is used for both the utility functions it provides, as well as the test capabilities exposed for the purposes of testing lua code
   -- This is especially good for testing neovim plugins because they have existing frameworks that can test individual neovim options
   - treesitter is used to color the test output and to find the test targets for some of the test libraries
   - FixCursorHold is not needed but recommended per {https://github.com/antoinemadec/FixCursorHold.nvim/issues/13}[This issue]
   - rust is the first specific library we need 
   -- since neotest itself is just a framework, we need plugins like these to provide test functionality for each individual language
   --- This lets this work be distributed between volunteers and makes it easy to submit work for a language you want to work without needing to contribute to the project itself, one can just make a repo that covers the work for a specific language that implements the framework.
   - we also have the work for python so that we can test stuff with the python series
** Setup
   With those local variables defined, all we need to do is setup the different test runner packages within our neotest setup function.
   #tangle neotest.lua
   @code lua
   return {
     "nvim-neotest/neotest",
     keys = activation_hotkeys,
     dependencies = dependencies_list,
     config = function()
       require("neotest").setup({
         adapters = {
           require("neotest-python"),
           require("neotest-rust"),
         },
       })
     end,
   }
   @end
   - We just need to require the various language plugins within the `adapters` section of our setup function.
* Telescope
  Telescope is one of the great plugins of neovim that makes it a pleasure to use

  Lazyvim already comes with it mostly installed and configured with the basics:
  - searching files
  - grepping files
  - searching buffers
  - and even searching diagnostic results OOTB
    I just wanted to add the functionality to search my URL bookmarks since that is the part that I think i was missing
** Buku Bookmarks Search
   Pretty much the only part i add on from lazyvim is the ability to do a search on my local buku repository using a combination of buku itself, and the `telescoppe-bookmarks.nvim` plugin which can read from the sqlite database located on your machine
   #tangle telescope.lua
   @code lua
   local buku_telescope_plugin_spec = {
     "dhruvmanila/telescope-bookmarks.nvim",
     dependencies = { "kkharji/sqlite.lua", "tyru/open-browser.vim" },
     keys = { { "<leader>sB", "<cmd>Telescope bookmarks<cr>", desc = "Search Bookmarks" } },
   }
   local telescope_browser_setup_options = {
     selected_browser = "buku",
     url_open_plugin = "open_browser",
     buku_include_tags = true,
   }
   local load_bookmark_extension = function()
     require("telescope").load_extension("bookmarks")
   end

   @end
   - We define the spec for installing and configuring the telescope-bookmarks plugin in the first place
   -- we need sqlite.lua to access the buku bookmarks themselves
   -- while open-browser is used to integrate with the browser of our choice so it opens our selection properly to the browser
   -- This whole thing is done with a single activation keymap and otherwise it just never gets loaded
   - Once we have installed the plugin we need to configure it within telescope itself
   -- here we pass the configuration saying we are using buku for where to get our bookmarks
   -- we are also noting that we have opten for the open-browser plugin see in the spec as our plugin of choice for opening links
   -- we also include the buku tags because I put allot of work into making those accurate and it can make it easier to find the bookmark if you know the tag it is likely a part of
   - Once all of that is done we can actually load the extension only AFTER telescope itself has completed its own setup

** Setup Call
   #tangle telescope.lua
   @code lua
   return {
     {
       "nvim-telescope/telescope.nvim",
       dependencies = { "nvim-lua/plenary.nvim",
         buku_telescope_plugin_spec,
       },
       config = function()
         require("telescope").setup({
           extensions = {
             bookmarks = telescope_browser_setup_options,
           },
         })
         load_bookmark_extension()
       end,
     }
   }
   @end
   Other than loading, configurating, and running the bookmarks plugin, this is a fairly standard telescope configuration
   - we put the plugin spec in the dependencies listing like any other
   - we configure telescope to include the new browser options as a table
   - and once telescope is loaded we can load the bookmarks extension itself
* ChatGPT
  ChatGPT can be configured with a specific plugin someone made to engage with the 3.5 model
  #tangle chatGPT.lua
  @code lua
  return {
    "jackMort/ChatGPT.nvim",
    config = true,
    event = "VeryLazy",
    dependencies = {
      "MunifTanjim/nui.nvim",
      "nvim-lua/plenary.nvim",
      "nvim-telescope/telescope.nvim",
    },
  }
  @end
  - we use nui and plenary to make it look good
  - while telescope is used as the menu that we primarily integrate with
* {https://github.com/mrjones2014/smart-splits.nvim}[Smart-Splits]
  We are also implementing smart splits, which implements a much more intuitive, coherent strategy for updating and changing split focus and sizing of different splits.

  The part where this goes from cool to mindblowing is its support for multiplexers so that we can ensure these split hotkeys are applicable whether or not we are in neovim
  - this includes support for wezterm! so I'm super excited to see this coming because this will help us really have the tmux-like experience that linux users have had for years.
** Base Config
   #tangle smartSplits.lua
   @code lua
   local smart_splits_config = {
     "mrjones2014/smart-splits.nvim",
     config = true,
   }

   @end
   - the only thing we are doing is design

*** Keymaps
    here we have to define not just the plugin, but the keymaps that will be used for it.
    - I could potentially use any of these first, so I will just put all of them in the keys table so that any one of them could be used to activate the plugin
    - Do note, we must encase all of the functions within a function call because we need this to be a callback, aka, we need to this be called AFTER the plugin is loaded since we will be utilizing functions that are not available until then
    -- without this we run into the dreaded "no plugin found" error even though we have clearly downloaded the plugin
    -- in addition, functions called this way must have an explicit `()` call at the end, since the functions are not evaluated until we are look at them and otherwise we still get an error whereas the readme is able to refer to them without using those function signs
       This is my first attempt at doing the config as a separate table and returning it distinctly but this allow me to actually follow the step-down principle of defining the most important bits of code first, followed by other methods
       We are taking the config table defined above and setting the keys index to the table defined, if done well, this should enable us to define the config iteratively rather than needing to construct it all at once
    #tangle smartSplits.lua
    @code lua
    smart_splits_config.keys = {}

    @end
    - in even more of a reversal I am actually going to just make an empty keys table and insert the keymaps into them one-by-one
**** Resize Keymaps
     First we are going to resize our current window/pane with the `ALT` Modifier
     #tangle smartSplits.lua
     @code lua
     table.insert(smart_splits_config.keys,{
       "<A-h>",
       function()
         require("smart-splits").resize_left()
       end,
       desc = "Resize Split Left",
     })
     table.insert(smart_splits_config.keys,{
       "<A-j>",
       function()
         require("smart-splits").resize_down()
       end,
       desc = "Resize Split Down",
     })
     table.insert(smart_splits_config.keys,{
       "<A-k>",
       function()
         require("smart-splits").resize_up()
       end,
       desc = "Resize Split Up",
     })
     table.insert(smart_splits_config.keys,{
       "<A-l>",
       function()
         require("smart-splits").resize_right()
       end,
       desc = "Resize Split Right",
     })

     @end
**** Move Focused Window Keymaps
     Now we will add keymaps to change our current focus when it comes to a window so that we can just use `CNTRL`+<direction key> to actually just move the focus to the closest directional windows/pane
     #tangle smartSplits.lua
     @code lua
     table.insert(smart_splits_config.keys,{
       "<C-h>",
       function()
         require("smart-splits").move_cursor_left()
       end,
       desc = "Move To Split on the Left",
     })
     table.insert(smart_splits_config.keys,{
       "<C-j>",
       function()
         require("smart-splits").move_cursor_down()
       end,
       desc = "Move To Split Below Current",
     })
     table.insert(smart_splits_config.keys,{
       "<C-k>",
       function()
         require("smart-splits").move_cursor_up()
       end,
       desc = "Move To Split Above Current",
     })
     table.insert(smart_splits_config.keys,{
       "<C-l>",
       function()
         require("smart-splits").move_cursor_right()
       end,
       desc = "Move To Split on the Right",
     })

     @end
**** Swapping Windows Keymaps
     Finally we have some keymaps behind the leader hotkeys' window subcommand to swap the currently focused window with the window in the defined direction
     - it should be noted this will be the only set of hotkeys likely not getting into the wezterm part initially only because idk if wezterm has implemented the swap feature yet
     #tangle smartSplits.lua
     @code lua
     table.insert(smart_splits_config.keys,{
       "<<leader><leader>-h>",
       function()
         require("smart-splits").swap_buf_left()
       end,
       desc = "Swap With Window on Left",
     })
     table.insert(smart_splits_config.keys,{
       "<<leader><leader>-j>",
       function()
         require("smart-splits").swap_buf_down()
       end,
       desc = "Swap With Window Below",
     })
     table.insert(smart_splits_config.keys,{
       "<<leader><leader>-k>",
       function()
         require("smart-splits").swap_buf_up()
       end,
       desc = "Swap With Window Above",
     })
     table.insert(smart_splits_config.keys,{
       "<<leader><leader>-l>",
       function()
         require("smart-splits").swap_buf_right()
       end,
       desc = "Swap With Window on Right",
     })

     @end
     --
     --
     #tangle smartSplits.lua
     @code lua
     return smart_splits_config
     @end
     - Finally, we return the config object defined at the beginning, and if all goes well, this should hold all of the proper logic without needing a rework or running into errors
