@document.meta
title: index
description: 
authors: root
categories: 
created: 2023-04-07
updated: 2023-04-09
version: 1.0.0
@end
Plugins are what really makes Neovim special, and here we can explore the magic (and frustration) of using plugins created for Neovim by the community

I think to start, I am just going to start with the smaller stuff and then work through it one at a time. Especially large plugins will likely get their own file so I can decouple them from what I have to do with the others which can be generated all at once
* Toggle Term
  Firsfirst we have the excellent {https://github.com/akinsho/toggleterm.nvim/tree/b86982429325112d2b20c6d0cc7a5c4b182ab706}[toggleterm.nvim] plugin that can be used to facilitate a workflow where I occasionally _toggle_ a terminal page, do some actions, and leave

  The snippet for enabling this is even easy:
  #tangle toggleTerm.lua
  @code lua
  return {
    "akinsho/toggleterm.nvim",
    version = "*",
    opts = {
      open_mapping = [[<c-\>]],
    },
  }
  @end
  - The version piece here is just going to grab the latest standard version
  -- This works because toggleterm follows SemVer
  - Otherwise, we just have to set the hotkey to _toggle_ the terminal on and off.
  -- Here we are using the standard `<c-\>` function to enable or disable the terminal itself
  --- this is hitting a conflict with the standard hotkey for neorg right now, not sure if I want to change this from the default or what that would be
  --- This is a kinda nice hotkey because it works outside and inside of the terminal, whereas normal hotkeys don't work in a terminal because it is basically always in insert mode
* Portal Configuration
  Portal is an interesting little plugin that enables us to visualize the jumplist before you just jump there.
  #tangle portal.lua
  @code lua
  return {
    "cbochs/portal.nvim",
    dependencies = { "cbochs/grapple.nvim" },
    keys = {
      { "<leader>o", "<cmd>Portal jumplist backward<cr>" },
      { "<leader>i", "<cmd>Portal jumplist forward<cr>" },
    },
  }
  @end
  - {https://github.com/cbochs/grapple.nvim/tree/ab274a3bfb674442d57fca05df866b71895853bc}[grapple.nvim] serves as the core library that allows for this file list and enable the preview capabilities
  - Otherwise, the plugin is only loaded when you use either of the keybinds above
  -- we chose `<leader>`o and i because it mirrors the normal jumplist hotkeys to express that they are paralell but different features
* Noice
  {https://github.com/folke/noice.nvim}[noice.nvim] is a super interesting, experimental plugin that was made by our resident hero folke.

  This plugin does many things, but chief among them is:
  - Introduction of great notifications via noice.nvim
  - Replacing command lines with a new popup format
  - and a bunch of other little things that make neovim really feel like an editor from the twenty first century

  #tangle noice.lua
  @code lua
  return {
    "folke/noice.nvim",
    cond = not vim.g.started_by_firenvim,
  }
  @end
* LSP Lines
  By Default, LSP diagnostics are displayed as virtual text at the end of the line
  Virtual Text is the text that is made outside of the buffer and can move to stick to a specific line rather than being present in the buffer
  - However, this makes it dificult to read all bust the most succinct warnings/errors
  - doubly-so for the case where we have multiple diagnostics/errors to review

  {https://github.com/ErichDonGubler/lsp_lines.nvim/tree/3b57922d2d79762e6baedaf9d66d8ba71f822816}[lsp_lines.nvim] attempts to fix this issue by replacing the default virtual text solution with one where instead each diagnostic gets its own line (hence the name) so multiple/long diagnostic messages can be shown without issue
  #tangle lspLines.lua
  @code lua
  return {
    "ErichDonGubler/lsp_lines.nvim",
    dependencies = { "neovim/nvim-lspconfig" },
    config = function()
      vim.diagnostic.config({
        virtual_text = false,
      })
      require("lsp_lines").setup()
    end,
    ft = { "lua", "python", "rust" },
  }
  @end
  - First, we need to ensure this is loaded after lspconfig since this relies on the configuration for this.
  - we have to use the functional way of setting up the plugin because we need to make a small change first
  -- The thing we need to do is disable the default virtual_text solution for diagnostics in Neovim
  --- if we dont, this will result in duplicate diagnostic messages when we are editing code
  --- afterwards, we can setup the plugin like normal
  - Finally, we need to restrict the filetypes that we enable lsp_lines on because otherwise we get annoying duplication in things like the lazy floating window
* Git Diff
  The standard diff view for Neovim is fine, but it leaves a few things to be desired.
  - It doesn't feel like a really integrated solution with the ability to show the context
  - More importantly, it can't show multiple files easily making the process of reviewing diffs for multiple files (as if often the case when we do `chezmoi apply`), then it can make the process feel cumbersome
  #tangle gitDiff.lua
  @code lua
  return {
    { "sindrets/diffview.nvim", dependencies = "nvim-lua/plenary.nvim" },
  }
  @end
* Chezmoi Support
  Chezmoi has a bunch of strange files so this (rather old) plugin justt ries to smooth over the rough edges by properly highlighting these files and whatnot.
  #tangle chezmoi.lua
  @code lua
  return {
    "alker0/chezmoi.vim",
  }
  @end
* Testing
  We are using a very exciting framework called {https://github.com/nvim-neotest/neotest}[neotest] where we can to do testing within neovim itself.
  It is a testing framework that is applicable to most languages so we can just setup a new configuration for each filetype
  In addition, it adds a bunch of UI elements that make the experience better using Neovim's newest UI improvements
** Keymaps
   This is one of those plugins we want to 
   #tangle neotest.lua
   @code lua
   local activation_hotkeys = {
     {
       "<leader>tS",
       function()
         require("neotest").summary.toggle()
       end,
       desc = "Toggle Neotest Summary",
     },
     {
       "<leader>tr",
       function()
         require("neotest").run.run()
       end,
       desc = "Run Nearest Test",
     },

     {
       "<leader>tf",
       function()
         require("neotest").run.run(vim.fn.expand("%"))
       end,
       desc = "Run Current File",
     },

     {
       "<leader>ts",
       function()
         require("neotest").run.run(vim.fn.getcwd())
       end,
       desc = "Run Test Suite",
     },
   }

   @end
   ~ Neotest includes a fancy test summary page that is able to visualize the file structure of your project and show not only the list of tests in each file but their actual test state! This hotkey toggles said summary
   ~~ Do note, We need to run the test suite BEFORE we can see the results within this fancy summary
   ~ Run Nearest Test to Cursor
   ~~ Useful for debugging during TDD which is why it's the first actual test
   ~~ While some languages have trouble running a full test suite, running a single test is almost always fine.
   ~ This one is for testing the entire file, useful if the test suite is big and slow
   ~~ that snippet `vim.fn.expand('%')` will return the name of the current buffer since this is the special character for the current buffer
   ~ Finally we have the test suite hotkey which will test the full test suite.
   ~~ While we want this to be our main hotkey, it is also the one more prone to breaking since the concept of a test suite and what is contained within varies between languages
** Dependencies
   #tangle neotest.lua
   @code lua
   local dependencies_list = {
     "nvim-lua/plenary.nvim",
     "nvim-treesitter/nvim-treesitter",
     "antoinemadec/FixCursorHold.nvim",
     "rouge8/neotest-rust",
     "nvim-neotest/neotest-python",
   }
   @end
   - Plenary is used for both the utility functions it provides, as well as the test capabilities exposed for the purposes of testing lua code
   -- This is especially good for testing neovim plugins because they have existing frameworks that can test individual neovim options
   - treesitter is used to color the test output and to find the test targets for some of the test libraries
   - FixCursorHold is not needed but recommended per {https://github.com/antoinemadec/FixCursorHold.nvim/issues/13}[This issue]
   - rust is the first specific library we need 
   -- since neotest itself is just a framework, we need plugins like these to provide test functionality for each individual language
   --- This lets this work be distributed between volunteers and makes it easy to submit work for a language you want to work without needing to contribute to the project itself, one can just make a repo that covers the work for a specific language that implements the framework.
   - we also have the work for python so that we can test stuff with the python series
** Setup
   With those local variables defined, all we need to do is setup the different test runner packages within our neotest setup function.
   #tangle neotest.lua
   @code lua
   return {
     "nvim-neotest/neotest",
     keys = activation_hotkeys,
     dependencies = dependencies_list,
     config = function()
       require("neotest").setup({
         adapters = {
           require("neotest-python"),
           require("neotest-rust"),
         },
       })
     end,
   }
   @end
   - We just need to require the various language plugins within the `adapters` section of our setup function.
* Telescope
  Telescope is one of the great plugins of neovim that makes it a pleasure to use

  Lazyvim already comes with it mostly installed and configured with the basics:
  - searching files
  - grepping files
  - searching buffers
  - and even searching diagnostic results OOTB
    I just wanted to add the functionality to search my URL bookmarks since that is the part that I think i was missing
** Buku Bookmarks Search
   Pretty much the only part i add on from lazyvim is the ability to do a search on my local buku repository using a combination of buku itself, and the `telescoppe-bookmarks.nvim` plugin which can read from the sqlite database located on your machine
   #tangle telescope.lua
   @code lua
   local buku_telescope_plugin_spec = {
     "dhruvmanila/telescope-bookmarks.nvim",
     dependencies = { "kkharji/sqlite.lua", "tyru/open-browser.vim" },
     keys = { { "<leader>sB", "<cmd>Telescope bookmarks<cr>", desc = "Search Bookmarks" } },
   }
   local telescope_browser_setup_options = {
     selected_browser = "buku",
     url_open_plugin = "open_browser",
     buku_include_tags = true,
   }
   local load_bookmark_extension = function()
     require("telescope").load_extension("bookmarks")
   end

   @end
   - We define the spec for installing and configuring the telescope-bookmarks plugin in the first place
   -- we need sqlite.lua to access the buku bookmarks themselves
   -- while open-browser is used to integrate with the browser of our choice so it opens our selection properly to the browser
   -- This whole thing is done with a single activation keymap and otherwise it just never gets loaded
   - Once we have installed the plugin we need to configure it within telescope itself
   -- here we pass the configuration saying we are using buku for where to get our bookmarks
   -- we are also noting that we have opten for the open-browser plugin see in the spec as our plugin of choice for opening links
   -- we also include the buku tags because I put allot of work into making those accurate and it can make it easier to find the bookmark if you know the tag it is likely a part of
   - Once all of that is done we can actually load the extension only AFTER telescope itself has completed its own setup

** Setup Call
   #tangle telescope.lua
   @code lua
   return {
     {
       "nvim-telescope/telescope.nvim",
       dependencies = { "nvim-lua/plenary.nvim",
         buku_telescope_plugin_spec,
       },
       config = function()
         require("telescope").setup({
           extensions = {
             bookmarks = telescope_browser_setup_options,
           },
         })
         load_bookmark_extension()
       end,
     }
   }
   @end
   Other than loading, configurating, and running the bookmarks plugin, this is a fairly standard telescope configuration
   - we put the plugin spec in the dependencies listing like any other
   - we configure telescope to include the new browser options as a table
   - and once telescope is loaded we can load the bookmarks extension itself
* Neorg Configuration
  Neorg is the primary tool used to replace things like markdown or even or org mode.

  This is actually the tool we are using to write this literate configuration!

  It takes more to setup than many of the other plugins but it can help with the ability to keep my thoughts together since it is the best note organization library and app i have found.
** Dependencies
   We have a few dependencies to take in because neorg utilizes many other plugins to get what it needs done.
   #tangle neorg.lua
   @code lua
   local neorg_dependencies = {
     "nvim-treesitter/nvim-treesitter",
     "hrsh7th/nvim-cmp",
     "nvim-neorg/neorg-telescope",
     {
       "folke/zen-mode.nvim",
       keys = { { "<leader>uz", "<cmd>ZenMode<cr>", desc = "Toggle Zen Mode" } },
       config = true,
       dependencies = { "folke/twilight.nvim", config = true },
     },
   }

   @end
   - Treesitter is the primary way that we are able to make sense of neorg files and are required to get not only syntax highlighting, but much of our other functionality as well since we rely on treesitter queries to do allot of automation.
   - These queries power cmp which uses some automation skripts created by the team to create completion entries while you type
   -- This inludes fun stuff like finishing todo actions
   -- making links
   -- and easily finishing stuff like code blocks
   - next we load the neorg telescope integration so that we can search our notes using telescope
   -- This extends to even being able to put links into the document while we are typing after we do a quick search first in telescope
   - Finally, zen mod is great for making a dedicated zen mode with our setup so that we have a way to easily focus when it is necessary
   -- we quickly set a hotkey to toggle zen mode within the UI section of our keymaps
   --- I put this here because it is deeply coupled with note taking i don't usually load this mode outside of neorg
   -- no real configuration to be done so we are able to just do `config = true` which translates to a normal setup run with no arguments
   -- Do not zen mode itself has a dependency in the form of twilight.nvim
   --- This is just used for the dimming effect when we go into zen mode, it makes the effect complete.
** Keymaps
   Neorg requires a bit more sophistication when it comes to keymaps because we must distringuish between two kinds here:
   - Keymaps that will start or load neorg
   -- Neorg is actually a fairly heavy plugin, so lazy loading it has resulted in a marked improvement of startup time. instead, we lazy load it if we use any of the following keymaps so we only pay the runtime cost when we actually need it and not when we are just trying to code
   - Keymaps that are used within a neorg document
   -- On top of making sure these plugins don't show up in other languages
   -- we are also defining these separately because sometimes we need to change an existing keymap that neorg already set
   --- in order to do this we are going to use neorg's own keybinding library to ensure this is all done within the system we defined
   #tangle neorg.lua
   @code lua
   local lazy_loading_keymaps = {
     { "<leader>nt", "<cmd>Neorg journal today<cr>",            desc = "Today's Journal Page" },
     { "<leader>nw", "<cmd>Neorg workspace work_notes<cr>",     desc = "Edit Work Notes" },
     { "<leader>nm", "<cmd>Neorg workspace main<cr>",           desc = "Edit Primary Notes" },
     { "<leader>nk", "<cmd>Neorg workspace knowledge_base<cr>", desc = "Edit Knowledge Base" },
     { "<leader>nc", "<cmd>Neorg workspace config<cr>",         desc = "Edit Literate Configuration" },
   }
   local norg_buffer_keymaps = {
     config = {
       neorg_leader = "<Leader>",
       hook = function(keybinds)
         keybinds.remap_key("norg", "n", "<C-s>", "<C-t>")
         keybinds.remap_key("norg", "i", "<C-l>", "<CS-l>")
         keybinds.map("norg", "n", "<leader>se", "<cmd>Telescope neorg search_headings<CR>")
         keybinds.map("norg", "n", "<leader>nr", "<cmd>Neorg return<CR>")
         keybinds.map("norg", "n", "<leader>nT", "<cmd>Neorg tangle current-file<CR>")
       end,
     },
   }

   @end
   - First we have the activation hotkeys to turn on neorg.
   -- First hotkey takes you directly to today's journaling page since we have our journal in neorg
   -- Next we have a quick hotkey to go to our work notes
   --- do note, this hotkey only works on my work laptop since it is the only one that will have the work neorg directory
   -- we then have a hotkey to go to our main neorg workspace
   --- good for debugging since that is our basic starting point
   -- we also have a hotkey to go to the knowledge base
   --- This is where "evergreen" or shared knowledge lives that is useful to both my personal and professional endeavors
   -- Then we have the hotkey to navigate to the literate config you are reading right now
   - Once we are in a norg file, we have introduced some extra keybinds for after neorg is loaded
   -- We also need to point out to neorg that `<space>` will be our leader
   -- first we needed to remap the default usage of `C-s` because it conflicted with my save hotkey
   -- ( ) we need to fix the second one, it is conflicting with wezterm right now
   -- the first new keymap is the ability to search the headings using telescope with `<leader>se`
   -- Neorg always keeps track of where you were before you entered neorg, so whenever you are ready to return to what you were doing before you started making notes, you can do `<leader>nr` to return to your previous activities
   -- Finally we have the code to actually tangle the file in the current buffer!
   --- This creates a new file in the current directory that will grab the tangled code and spit it out to that new file
** Module Configuration
   One of the pieces that excites me about neorg is that they have done a good job of splitting the project into modules so that you can configure, remove, and add modules to your heart's content.
   - This means that some modules need extra love but others can become invaluable
   - it also makes the prospect of adding to neorg easy since you can easily define and load a custom plugin without needing to contribute to neorg itself

   We are going to take some time to configure a few of the bigg modules to make the final setup function more concise
*** Dirman
    Dirman is probably the primary module that needs to be updated frequently. This is the module that controls the list of neorg directories and where we list out the various directories that compose our neorg workspaces.
    It also has a few configuration options of its own that we can tinker with with whenever we need.
    #tangle neorg.lua
    @code lua
    local dirman_configuration = {
      config = {
        workspaces = {
          main = "~/neorg",
          work_notes = "~/work_neorg_notes",
          knowledge_base = "~/knowledge_base",
          config = "~/.local/share/chezmoi/literate_config",
        },
        autochdir = true,
        index = "index.norg",
        last_workspace = vim.fn.stdpath("cache") .. "/neorg_last_workspace.txt",
      },
    }

    @end
    - first we define our various workspaces
    -- main is our primary workspace that we will keep journal notes and other personal notes
    -- work is meant for sensitive work-related notes and as such is only made available on the work laptop
    --- however it's nice that this doesn't break the plugin when i'm not on the work laptop
    -- knowledge base is where we keep much of our shared, evergreen knowledge
    -- config is the site of this literate config!
    --- intended to be the bain that powers my personal configuration and gives me context around all these tools i use.
    - With our workspaces defined we just have a few settings to set
    -- we note that we are using autochdir so that the ability to search for links properly works as we are flying around the neorg setup
    --- if we dont tick this then it breaks as we navigate through the knowledge base
    --- we can have a file with a different name that serves as the index for the folder, but here we opt for just the standard index file
    --- and finally we can define the last workspace by grabbing this last workspace.txt file that is apparently placed into our cache directory by neorg itself so we can easily go to the last workspace whenever we need
*** Module List
    Here we will just define the entire module list so that we can discuss and grow it naturally over time
    I also want to decouple it from the rest of the lazy configuration because there is already enough to talk about in that chunk

    One note about lua before we dive in, one will immediately note that we have this strange way of setting different indexes within the table.
    This is using the same mechanism as if we were to set the index of a table with a number, only instead we are using strings instead.
    - This means each module is a table that is indexed via its name within one large table for neorg.
    - to remove a module we can just remove the entry in the table
    #tangle neorg.lua
    @code lua
    local module_list = {
      ["core.defaults"] = {},
      ["core.norg.concealer"] = {},
      ["core.norg.dirman"] = dirman_configuration,
      ["core.presenter"] = {
        config = {
          zen_mode = "zen-mode",
        },
      },
      ["core.norg.completion"] = {
        config = {
          engine = "nvim-cmp",
        },
      },
      ["core.keybinds"] = norg_buffer_keymaps,
      ["core.norg.qol.toc"] = {},
      ["core.norg.journal"] = {
        config = {
          journal_folder = "/journal/",
          use_folders = true,
          workspace = "main",
        },
      },
      ["core.norg.esupports.metagen"] = {
        config = {
          type = "auto",
        },
      },
      ["core.export"] = {},
      ["core.export.markdown"] = {},
      ["core.integrations.telescope"] = {},
    }
    @end
    - First we have the defaults module which loads all the default modules for neorg to get us started
    - The concealer uses treesitter to dynamically hide content on the buffer page to make it easier to read
    -- this is how we have these funny characters replace the headers based on level and what not
    --- definately one of the more finicky parts of neorg but it does such good work that I can't stop it from doing its thing
    - we setup dirman with the table that was defined earlier
    - we are using zen.nvim as our writing zen mode and just highlighting that connection to neorg
    - we are also highlighting that we are using cmp as our completion engine and setting that for the neorg completion settings
    - keybinds are simply those post-loading keymaps we defined earlier along with setting the leader key
    - I also use neorg for journaling, and have been loving it
    -- we use the directory structure where we have files loaded within directories for each day
    -- we keep all of this in the main neorg workspace rather than a dedicated jouranl workspace
    --- ( ) although it might be worth making a dedicated journal workspace to ensure that is also decoupled from more banal thoughts that could be shared with others
    - another amazing feature is neorgs perpensity to put in metadata on the top of all files
    -- this is just a nice to have for now, but it points towards even deeper integrations since we can arbitrary data fields to documents so that we can easily search and automate them based on their metatdata
    --- for now we just automatically generate it but I look forward to using this as a process in and of itself
    - another critical piece for adoption is the ability to export these notes to other formats this is where the export module comes in so we can automatically make other file types based on this
    -- for now we only load the markdown export module for markdown integration but I look forward to seeing more
    - Finally we add the telescope integrations we got in the dependencies list. nothing to do on our end it will just add some neorg related commands within the telescope sub menu

** Setup
   With all that setup done we are ready to call the steup function itself
   #tangle neorg.lua
   @code lua
   return {
     {
       "nvim-neorg/neorg",
       build = ":Neorg sync-parsers",
       dependencies = neorg_dependencies,
       ft = "norg",
       keys = lazy_loading_keymaps,
       config = function()
         require("neorg").setup({
           load = module_list,
         })
       end,
     },
   }
   @end
   - As I noted earlier, treesitter is an important part of making this all work so whenever we build a new version of neorg, we need to be sure to run that sync-parsers command
   -- this will go out and install the latest treesitter grammars and ensure we dont run into issues where we have an older treesitter grammer than the version of neorg itself
   - we place the dependencies from earlier here
   - we also place the activiation hotkeys here to tell lazy to load neorg only after we click one of these hotkeys
   - we also have set a lazy load on filetype condition where we will load the plugin if we are editing a norg file within the current buffer
   - After that all we have to do is load the module list for our setup function and we are off to the races!
