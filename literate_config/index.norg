@document.meta
title: index
description: 
authors: root
categories: 
created: 2023-04-05
updated: 2023-04-25
version: 1.0.0
@end
This is the configuration Neorg workspace. This workspace is extra special because it will be the site of an experiment.

We are going to attempt something I have wanted to try but have never felt like I had the tooling required.

Specifically, we are going to leverage the tangling feature of neorg to actually write the various configuration files needed to keep the system running.

We have gotten to the point where the code is rather concise, but it would take allot of context to understand what is going on in each file and how each one connects with the other.

This is where tangling comes in. These neorg files will actually generate the data that we expect to use throught this work.

As far as the structure goes I'm still tinkering with it but for right now I think there will be a norg file for every normal file unless they are rather small so I can ensure that everything is kept tidy

* {:wezterm:}[Wezterm Configuration]
* {:Neovim/index:}[Neovim Configuration]
* Chezmoi
  Chezmoi is the glue that is holding all of this together, and as such should be understood first only after Neovim itself
  Feel free to review the Chezmoi knowledge itself for further reference, here we are just going to define our chezmoi setup and why we made the decisions we did
** Config File
   We are opting to do the standard chezmoi TOML file
   #tangle .chezmoi.toml.tmpl
   @code toml
   {{ if eq .chezmoi.os "windows" }}
   [cd]
   command = "pwsh"
   {{ end }}

   [diff]
   command = "nvim"
   args = "-d"

   [edit]
   command = "nvim"

   [git]
   autoCommit = true
   @end
   - windows has this annoying thing where it defaults to the cmd for most things so we need to just start it in powershell whenever we use the `chezmoi cd` command
   - for the diffing mechanism between chezmoi and the files, I use neovim's default diff mode
   -- we do this by running neovim with the `-d` argument
   --- ( ) However, in the future I still want to change this over to using the diffview plugin instead to improve the user experience and get them all in one go
   - We are using neovim whenever we do `chezmoi edit`
   - Finally we have autocommit set to true so that whenever we add a change to our config it autocommits the changes to the repo to make the process of updating the config more seamless
** Ignore File
   Another surprisingly import file, since this is one of the main mechanisms we use to control the different configuration variations between the different OSs
   #tangle .chezmoiignore
   @code gitignore
   {{ if ne .chezmoi.os "windows" }}
   AppData/
   Documents/
   .chezmoiscripts/*.ps1
   dot_ssh/config
   {{ else }}
   dot_config/nvim/
   .chezmoiscripts/*.sh
   {{ end }}

   ./literate_config/
   @end
   - If we are not in windows, we are removing the `AppData`, `Documents`, and all PowerShell files from the `.chezmoiscripts` directory
   -- These folders are a microsoft thing, and shouldn't make their way into linux directories
   --- specifically, this is where the neovim config and powershell script are respectively.
   - Otherwise, we are removing the `nvim` folder from the `.config` file
   -- so we don't conflict with the version that is used in windows
   - finally, we ignore this folder! 
   -- because it is not intended to be copied to the machine's home directory, it is intended to serve as the brain of the repository itself and thus should never be included

* Git
  The software that has enabled all of this is Chezmoi, a dotfile manager that can give users the ability to have a single configuration with minor edits to accomodate different OSs as well as different needs for different machines.

  While this wont be the main place we talk about the inner workings of Chezmoi, I will leave that to the {:$knowledge_base/Applications/Chezmoi/index:}[Chezmoi Knowledge Files]

  Instead, here we are going to define our chezmoi files and explain why we have made the decisions we did

  Our git configuration file is one of the first places where we start leveraging the template abilities of chezmoi:
  #tangle .gitconfig.tmpl
  @code gitconfig
  [user]
  {{- if eq .chezmoi.hostname "USMINDARBURGES1" }}
  email = darburgess@deloitte.com
  {{ else }}
  email = dargondab9@gmail.com
  {{- end }}
  name = Darrion Burgess

  [core]
  symlinks = true

  [credential]
  {{- if eq .chezmoi.os "windows" }}
  helper = C:/Program\\ Files/Git/mingw64/bin/git-credential-manager
  {{- else }}
  helper = /mnt/c/Program\\ Files/Git/mingw64/bin/git-credential-manager.exe
  {{- end}}
  @end
  - The main variation comes with the email that gets set for the git pieces
  -- the work one just changes the email to my standard work email
  -- While any other time we use the standard email associated with our personal GH account
  - Finally, we are using gits' built-in credential storing feature to store our PAT tokens within the local machine
  -- While it is generally considered bad-practice to store secret in plaintext in a repo, we have avoided that in the credential file itself by outsourcing this work to the 1password CLI which you will see below
  - finally we need to put in this symlinks option to make this symlink hack we are relying on work between windows and linux per {https://stackoverflow.com/questions/5917249/git-symbolic-links-in-windows/59761201#59761201}[This discussion about symlinks between linux and windows]
  - we also also make openSSH our agent on windows per {https://developer.1password.com/docs/ssh/get-started}[This 1password tutorial]
** Git Credentials Using PAT Tokens
   PAT Tokens are the recommended way to get this stuff done.
   we are going to use 1Password to get this all going but we are just trying to make this all work
   #tangle gitCredentials
   * Shell Configuration
   Here, we are going to walk through any configuration that is needed for the Shell in question, this will likely look largely the same, but with minor tweaks based on the OS or if it is a work machine but should otherwise remain minimal
** Bash
   Bash should be relatively straightforward, with the exception of my custom prompt and adding some things to the path
*** Adding bob-nvim to the path
    We use bob-nvim for our managing Neovim versions, and in order to use the current version of Neovim, we need to add it to our path
    #tangle .bashrc.tmpl
    @code bash
    export PATH="/home/$USER/.local/share/bob/nvim-bin:$PATH"

    @end
    - We are manually appending the absolute path to the binary that is currently selected for bob-nvim, the Neovim version manager
    -- Again, this means we need to have bob-nvim already installed on the machine for this to do anything
*** Making our OpenAI API Key available
    OpenAI is the company behind ChatGPT and other innovative products at the cutting edge of Artificial General Intelligence.
    In order to use their API, we need to have an API key, which we store in 1Password.

    We will be leveraging Chezmois' template function to read the API key from 1Password and export it as an environment variable.
    #tangle .bashrc.tmpl
    @code bash
    export OPENAI_API_KEY="{{ onepasswordRead "op://Personal/openai_api_key/notesPlain" }}"

    @end
    - Add the api key for open AI including ChatGPT and other tools
    -- this is going to use the onepassword template for Chezmoi so that we can revoke and change this key should we ever need
    -- it also means we effectively have two chained dependencies. Chezmoi for the templating functionality, which is using 1password as the secrets manager
*** Adding the Cargo and NodeJS version managers
    We are going to be using Rust and NodeJS for a lot of the tooling we are going to be installing, so we need to make sure we have the version managers installed for rustup and nvm respectively
    We are going to be using the following tools:
    - {https://rustup.rs/}[Rust]
    - NodeJS:
    #tangle .bashrc.tmpl
    @code bash
    . "$HOME/.cargo/env"

    export NVM_DIR="$HOME/.nvm"
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"

    @end
    - Remember that the `.` at the beginning is equivalent to if we had written the `source` command
    -- Therefore, we are effectively sourcing the `.cargo/env` file from the `$HOME` directory
    --- This requires that cargo is installed since this is ensuring we make the environment from cargo available to the shell
    - Exports nvms' bin via your `.bashrc` automatically after it is installed via the installation script in Linux
    -- The line after that loads a shell script that makes nvm available to the system
    -- and finally loads bash completions once the first two steps are done so that the application is ready to use out of the box
*** Using 1Password as our SSH Agent within WSL
    1Password has a pretty cool mechanism of using SSH keys that kicks the crap out of my current git credentials scheme.
    To this end, we are going to be following {https://dev.to/d4vsanchez/use-1password-ssh-agent-in-wsl-2j6m#:~:text=To%20communicate%20between%20WSL%20and%20the%201Password%20SSH,the%20GitHub%20repository%20and%20download%20the%20latest%20release.}[These Instructions] to add 1Password as our SSH Agent within WSL
**** Dependencies
     This hack requires two dependencies:
     - `npiperelay` needs to be installed on the windows side so we can pipe information to WSL
     - while we will be using `socat` on the WSL side to send these signals
     - we also need a `.1password` folder created within the home directory
**** Adding 1password as the SSH agent
     Within the linux environment we need to create a new configuration file for SSH on linux if there isn't one already in which we put 1password as our main ssh provider
     This snippet is directly from the 1password website:
     #tangle sshConfig
     @code sshconfig
     Host *
     IdentityAgent ~/.1password/agent.sock
     @end
     - This is where the folder we created earlier comes in to play, we need to make sure it is there to be populated from our script later
       --
       now we can put the following snippet at the end of our bash RC
     #tangle .bashrc.tmpl
     @code bash
     {{- if eq .chezmoi.os "linux" }}
     {{-   if (.chezmoi.kernel.osrelease | lower | contains "microsoft") }}
     export SSH_AUTH_SOCK=$HOME/.1password/agent.sock

     ALREADY_RUNNING=$(ps -auxww | grep -q "[n]piperelay.exe -ei -s //./pipe/openssh-ssh-agent"; echo $?)

     if [[ $ALREADY_RUNNING != "0" ]]; then
     if [[ -S $SSH_AUTH_SOCK ]]; then
     echo "removing previous socket..."
     rm $SSH_AUTH_SOCK
     fi
     echo "Starting SSH-Agent relay..."
     (setsid socat UNIX-LISTEN:$SSH_AUTH_SOCK,fork EXEC:"npiperelay.exe -ei -s //./pipe/openssh-ssh-agent",nofork &) >/dev/null 2>&1
     fi
     {{   end }}
     {{ end }}
     @end
     ~ we only want this snippet inserted for WSL instances so we leverage chezmoi's `os` and `kernel.osrelease` variables to determine if we are running on WSL
     ~ We configure the ssh auth socket to be the one we want to use in our new `.1password` directory
     ~ Next, we check if the relay is already running. We do this by checking if the `npiperelay.exe` process is running. 
     ~~ We do this by grepping for the process name, but we need to exclude the grep command itself, so we use square brackets to generate a regex match for the process we want but that doesn't match the grep command running it!
     ~~ we need powershell to get the non-truncated command for matching
     ~ If the relay isn't running, we check if the socket is already in use. If it is, we remove it.
     ~ Finally, we start the relay in the background and redirect the output to `/dev/null` so it doesn't clutter up our terminal
     ~~ We use `setsid` to force a new session so that the relay keeps running even if we close our terminal
     ~~ We use `socat` to listen on the ssh auth socket and forward to `npiperelay` which then forwards to `openssh-ssh-agent` on windows
*** Enable Starship Prompt
    Lastly, we will enable the starship prompt, this is a nice prompt that is highly customizable and has a lot of nice features
    #tangle .bashrc.tmpl
    @code bash
    eval "$(starship init bash)"
    @end
    - We have the evaluation of the starship prompt
    -- This requires that the startship prompt is already installed on the system
    - must be enabled last otherwise we start getting strange errors around not being able to call the starship command 
** PowerShell
   PowerShell will look largely the same as bash, only with a few variations on the commands for PowerShell
   #tangle Microsoft.PowerShellProfile.ps1.tmpl
   @code ps1
   $prompt = ""
   function Invoke-Starship-PreCommand {
   $current_location = $executionContext.SessionState.Path.CurrentLocation
   if ($current_location.Provider.Name -eq "FileSystem") {
   $ansi_escape = [char]27
   $provider_path = $current_location.ProviderPath -replace "\\", "/"
   $prompt = "$ansi_escape]7;file://${env:COMPUTERNAME}/${provider_path}$ansi_escape\"
   }
   $host.ui.Write($prompt)
   }
   Invoke-Expression (&starship init powershell)

   $Env:OPENAI_API_KEY = "{{ onepasswordRead "op://Personal/openai_api_key/notesPlain" }}"

   @end
   - This first function was pulled directly from the {https://wezfurlong.org/wezterm/shell-integration.html}[Shell Integration Page of Wezterm] to allow us to hook into starship prompt and provide OSC 7 codes.
   -- Functions like this advise the terminal on the working directory
   - Again, we are just invoking the startship prompt
   -- Therefore, we just need to be sure it is installed on the machine before we put this configuration file in here

   This config file has less manual work than the bash file because windows in general believes less in managing system configuration through the shell.
   Instead they often opt to change configuration through dedicated GUI programs or other discrete tools that need to be setup before the shell is even started, however, once you are done, there is less manual wiring required to get the application running than in the bash shell.
* First-Time-Setup and Initial Machine Installations
  When we first get a machine, unless we are operating from a dockerized mindset, we will likely need to setup the environment first to ensure that everything we have setup above works as intended.
  This can be difficult as much of this is different between different OSs, and while some software can be installed easily and automatically, others must be install through more manual means that make it difficult to reproduce in an easy manner
** Linux
   First we will cover the linux things that need to get done since there seems to be a bit more to be done before we can use the bash shell
*** Installing Rust Toolchain
    The rust toolchains (including rustup, cargo, clippy, and more) can be installed with a one-line script:
    #tangle installCargo.sh.tmpl
    @code template
    #!/bin/bash
    if command -v cargo > dev/null; then
    echo "rust and cargo are already installed, exiting"
    exit
    else
    {{if (.chezmoi.kernel.osrelease | lower | contains "microsoft") }}
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    {{else}}
    curl https://sh.rustup.rs -sSf | sh
    {{end}}
    fi
    @end
    - The first level of logic simply checks if we already have rust installed, since chezmoi tries to run the script each time to do an apply
    -- We only want to run the curl command(s) if we need to so first we check if cargo is executable, if so, we just exit early
    - This was grabbed directly from the {https://doc.rust-lang.org/cargo/getting-started/installation.html}[Rust Book's Installation Section]
    -- If all goes well, you should see a message that says "Rust is installed now. Great!"
    --- You will also need to restart your shell to ensure the new cargo environment is loaded
    ---- or you can just source your bashrc
    - We run one script if we are in a WSL distro specifically
    -- Otherwise, we are just going to run the standard installation script
** Windows
   Windows has actually become the easier of the two to install much of our software since it can often be accomplished with the new `winget` CLI tool
   Even if that one doesn't work, `scoop` or `choco` will likely have whatever winget is missing
*** Installing Rust Toolchain on Windows

