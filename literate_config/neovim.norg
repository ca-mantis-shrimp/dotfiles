@document.meta
title: Neovim Configuration
description: Starting point for Neovim Configuration
authors: darburgess
categories: index
tangle: .local/share/chezmoi/.chezmoitemplates/Neovim/init.lua
created: 2023-04-07
updated: 2024-04-19T20:57:21-0800
version: 1.0.0
@end
Configuring Neovim is probably our primary focus as far as keeping a dotfile configuration goes.

Neovim is the beating heart at the center of the configuration, and undergoes rapid changes in configuration and the technologies used within the stack since the velocity of the Neovim application itself is so high.
- This means that we have to put extra work into ensuring the configuration is both robust enough to do what we want to do.
- While also keeping up engineering practices that can keep it productive while I use it as a work product.

To do this, we are going to be using {https://github.com/nvim-lua/kickstart.nvim?tab=readme-ov-file#Install-Recipes}[kickstart.nvim to] to kickstart our configuration (pun intended)


* What is Kickstart?

  Kickstart.nvim is *not* a distribution.

  Kickstart.nvim is a starting point for your own configuration.
  The goal is that you can read every line of code, top-to-bottom, understand
  what your configuration is doing, and modify it to suit your needs.

  Once you've done that, you can start exploring, configuring and tinkering to
  make Neovim your own! That might mean leaving Kickstart just the way it is for a while
  or immediately breaking it into modular pieces. It's up to you!

  If you don't know anything about Lua, I recommend taking some time to read through
  a guide. One possible example which will only take 10-15 minutes:
  - {https://learnxinyminutes.com/docs/lua/}[Learn X in Y Minutes: Lua]

  After understanding a bit more about Lua, you can use `:help lua-guide` as a
  reference for how Neovim integrates Lua.
  - `:help lua-guide`
  - (or HTML version): {https://neovim.io/doc/user/lua-guide.html}[Lua Guide]

** Kickstart Guide
   First, run AND READ `:help`.
   This will open up a help window with some basic information
   about reading, navigating and searching the builtin help documentation.

   This should be the first place you go to look when you're stuck or confused
   with something. It's one of my favorite Neovim features.

   MOST IMPORTANTLY, we provide a keymap `<space>sh` to (s)earch the (h)elp documentation,
   which is very useful when you're not exactly sure of what you're looking for.

   I have left several `:help X` comments throughout the init.lua
   These are hints about where to find more information about the relevant settings,
   plugins or Neovim features used in Kickstart.


   If you experience any errors while trying to install kickstart, run `:checkhealth` for more info.
** Setting Options
   Options are the fundamental configuration blocks of the configuration and should be set first as to enable other plugins to take advantage of the settings you are activating. Remember, order does matter for the most part and so we want to make sure we are setting these things early especially where they are relied upon by several plugins such as the `mapleader` setting
*** Mapleader and Nerd fonts
    One of these concepts is fundamental to understanding the neovim ecosystem while the other is an optional, but fun feature that allows us to use characters besides the normal text we associate with a text editor

    the key quality they share is that they need to be loaded early, near first if possible, this is because so many things take advantage of these settings and check them that we want this to be done before we continue with the rest of the configuration
    @code lua
    vim.g.mapleader = ' '
    vim.g.maplocalleader = ' '

    vim.g.have_nerd_font = true
    @end
*** Setting Options
    Next, we move on to the fundamental concept of options which are the configuration values that neovim itself uses. However, like the earlier ones, many of these are used by plugins and other functionality to change your experience so its best that they are set early to reduce headaches around setting configuration options
    See `:help vim.opt`
    For more options, you can see `:help option-list`
    @code lua
    vim.opt.number = true
    vim.opt.relativenumber = true

    vim.opt.mouse = 'a'

    vim.opt.showmode = false

    vim.opt.breakindent = true

    vim.opt.undofile = true

    vim.opt.ignorecase = true
    vim.opt.smartcase = true

    vim.opt.signcolumn = 'yes'

    vim.opt.updatetime = 250

    vim.opt.timeoutlen = 300

    vim.opt.splitright = true
    vim.opt.splitbelow = true

    vim.opt.list = true
    vim.opt.listchars = { tab = '» ', trail = '·', nbsp = '␣' }

    vim.opt.inccommand = 'split'

    vim.opt.cursorline = true
    vim.opt.scrolloff = 10

    vim.opt.hlsearch = true
    @end
    ~ Making the visualization of line numbers default
    ~ We are also adding relative line numbers, to help with jumping.
    ~ Enable mouse mode 
    ~~ can be useful for resizing splits for example!
    ~ Disabling `showmode`, since it's already in the status line
    ~ Enable `breakindent`
    ~ Save undo history
    ~ Case-insensitive searching UNLESS \C or one or more capital letters in the search term
    ~ Keep `signcolumn` on by default
    ~ Decrease update time
    ~ Decrease mapped sequence wait time
    ~~ Displays which-key popup sooner
    ~ Configure how new splits should be opened
    ~~ we default to splitting right and below respectively
    ~ Sets how neovim will display certain whitespace characters in the editor.
    ~~  See `:help 'list'`
    ~~~  and `:help 'listchars'`
    ~ Preview substitutions live, as you type!
    ~ show which line your cursor is on
    ~ Minimal number of screen lines to keep above and below the cursor.
    ~ Set highlight on search 
    ~~ but clear on pressing <Esc> in normal mode later

** Setting Vanilla Keymaps
   Next, we are going to be setting all of the keymaps we can set BEFORE any plugins are loaded.

   Again, this allows us to ensure the keymaps that utilize only vanilla neovim functionality are set before loading our plugins.
   In addition, some plugins like `which-key` actually use our plugins to display keymaps, so we want to make sure they are set before we load those plugins
   See `:help vim.keymap.set()`
   @code lua
   vim.keymap.set('n', '<Esc>', '<cmd>nohlsearch<CR>')
   @end
   - just capping off the hlsearch workflow we started above by removing that same search on escape, otherwise you have to deal with wonkiness around your search highlighting
*** Diagnostics
    `:h vim.diagnostic` is our one-stop-shop for all diagnostic information that is fed in from tools like our LSP servers later on but can be used to store several types of information so we can navigate around our codebase more effectively
    @code lua
    vim.keymap.set('n', '[d', vim.diagnostic.goto_prev, { desc = 'Go to previous [D]iagnostic message' })
    vim.keymap.set('n', ']d', vim.diagnostic.goto_next, { desc = 'Go to next [D]iagnostic message' })
    vim.keymap.set('n', '<leader>e', vim.diagnostic.open_float, { desc = 'Show diagnostic [E]rror messages' })
    vim.keymap.set('n', '<leader>q', vim.diagnostic.setloclist, { desc = 'Open diagnostic [Q]uickfix list' })
    @end
*** Terminal Keymaps
    Exit terminal mode in the builtin terminal with a shortcut that is a bit easier for people to discover. 
    Otherwise, you normally need to press `<C-\><C-n>`, which is not what someone will guess without a bit more experience.

    @code lua
    vim.keymap.set('t', '<Esc><Esc>', '<C-\\><C-n>', { desc = 'Exit terminal mode' })
    @end
*** Split Navigation
    Use CTRL+<hjkl> to switch between windows
    - See `:help wincmd` for a list of all window commands
    @code lua
    vim.keymap.set('n', '<C-h>', '<C-w><C-h>', { desc = 'Move focus to the left window' })
    vim.keymap.set('n', '<C-l>', '<C-w><C-l>', { desc = 'Move focus to the right window' })
    vim.keymap.set('n', '<C-j>', '<C-w><C-j>', { desc = 'Move focus to the lower window' })
    vim.keymap.set('n', '<C-k>', '<C-w><C-k>', { desc = 'Move focus to the upper window' })
    @end
** Basic AutoCommands
   See `:help lua-guide-autocommands`
   Highlight when yanking (copying) text
   - Try it with `yap` in normal mode
   --  See `:help vim.highlight.on_yank()`
   @code lua
    vim.api.nvim_create_autocmd('TextYankPost', {
      desc = 'Highlight when yanking (copying) text',
      group = vim.api.nvim_create_augroup('kickstart-highlight-yank', { clear = true }),
      callback = function()
        vim.highlight.on_yank()
      end,
    })
   @end
* Plugins
** Lazy, the plugin manager itself
   See `:help lazy.nvim.txt` or {https://github.com/folke/lazy.nvim}[lazy.nvim on github] for more info
*** Bootstrapping Lazy
    Lazy is the first plugin in our plugin order so there is a bit of a chicken and egg situation, we cant use lazy until it is installed so we need to actually install it ourselves and set some setting to ensure it is all ready for work
    @code lua
    local lazypath = vim.fn.stdpath 'data' .. '/lazy/lazy.nvim'
    if not vim.loop.fs_stat(lazypath) then
    local lazyrepo = 'https://github.com/folke/lazy.nvim.git'
    vim.fn.system { 'git', 'clone', '--filter=blob:none', '--branch=stable', lazyrepo, lazypath }
    end ---@diagnostic disable-next-line: undefined-field
    vim.opt.rtp:prepend(lazypath)
    @end
    To check the current status of your plugins, run `:Lazy`

    You can press `?` in this menu for help. Use `:q` to close the window

    To update plugins you can run
    `:Lazy update`

    Here is where you install your plugins.
    Plugins can be added with a link (or for a github repo: 'owner/repo' link).

    Plugins can also be added by using a table, 
    - with the first argument being the link and the following
    - keys can be used to configure plugin behavior/loading/etc.
    - Use `opts = {}` to force a plugin to be loaded.
    -- This is equivalent to: `require('Comment').setup({})`
*** Starting Lazy Spec
    All of lazy is configured using a single big-ass table that is started from here:
    @code lua
    require('lazy').setup({
    @end
** {https://github.com/tpope/vim-sleuth}[vim-sleuth]
   Detect tabstop and shiftwidth automatically
   @code lua
   'tpope/vim-sleuth', 
   @end
** {https://github.com/numToStr/Comment.nvim}[Comment.nvim]
   Adds some great comment functionality that makes commenting most languages a breeze out of the box
   @code lua
   { 'numToStr/Comment.nvim', opts = {} },
   @end
   - `gc` to comment visual regions/lines
** {https://github.com/lewis6991/gitsigns.nvim}[gitsigns.nvim]
   Here is a more advanced example where we pass configuration
   options to `gitsigns.nvim`. This is equivalent to the following Lua:
   `require('gitsigns').setup({ ... })`

   See `:help gitsigns` to understand what the configuration keys do
   Adds git related signs to the gutter, as well as utilities for managing changes
   @code lua
   {
   'lewis6991/gitsigns.nvim',
   opts = {
   signs = {
   add = { text = '+' },
   change = { text = '~' },
   delete = { text = '_' },
   topdelete = { text = '‾' },
   changedelete = { text = '~' },
   },
   },
   },
   @end
** {https://github.com/folke/which-key.nvim}[Which-Key]
   The hotkey plugin from neovim's own plugin artisan such that we are able to show the hotkeys as we type, allowing us a much faster experience when it comes to calibrating our hotkeys and growing them organically
   Plugins can also be configured to run Lua code when they are loaded.

   This is often very useful to both group configuration, as well as handle
   lazy loading plugins that don't need to be loaded immediately at startup.

   For example, in the following configuration, we use:
   event = 'VimEnter'

   which loads which-key before all the UI elements are loaded. Events can be
   normal autocommands events (`:help autocmd-events`).

   Then, because we use the `config` key, the configuration only runs
   after the plugin has been loaded:
   `config = function() ... end`

   In this initial example, we are primarily noting existing key chains to make them more readable later
   @code lua
   { 
   'folke/which-key.nvim',
   event = 'VimEnter', 
   config = function() 
   require('which-key').setup()

   require('which-key').register {
   ['<leader>c'] = { name = '[C]ode', _ = 'which_key_ignore' },
         ['<leader>d'] = { name = '[D]ocument', _ = 'which_key_ignore' },
         ['<leader>r'] = { name = '[R]ename', _ = 'which_key_ignore' },
         ['<leader>s'] = { name = '[S]earch', _ = 'which_key_ignore' },
         ['<leader>w'] = { name = '[W]orkspace', _ = 'which_key_ignore' },
         ['<leader>t'] = { name = '[T]oggle', _ = 'which_key_ignore' },
         ['<leader>h'] = { name = 'Git [H]unk', _ = 'which_key_ignore' },
       }
       require('which-key').register({
         ['<leader>h'] = { 'Git [H]unk' },
       }, { mode = 'v' })
     end,
   },
   @end
** {https://github.com/nvim-telescope/telescope.nvim}[Telescope]
   Telescope is the neovim-specific fuzzy find interface that allows us to search thousand of files, buffers, or anything else you might want to search at the blink of an eye

   Remember, Plugins can specify dependencies.

   The dependencies are proper plugin specifications as well - anything
   you do for a plugin at the top level, you can do for a dependency.

   Use the `dependencies` key to specify the dependencies of a particular plugin
   If encountering errors, see telescope-fzf-native README for installation instructions
   - `build` is used to run some command when the plugin is installed/updated.
   -- This is only run then, not every time Neovim starts up.
   - `cond` is a condition used to determine whether this plugin should be installed and loaded.
     The easiest way to use Telescope, is to start by doing something like:
     `:Telescope help_tags`

   After running this command, a window will open up and you're able to
   type in the prompt window. You'll see a list of `help_tags` options and
   a corresponding preview of the help.

   Two important keymaps to use while in Telescope are:
   - Insert mode: `<c-/>`
   - Normal mode: `?`

   This opens a window that shows you all of the keymaps for the current
   Telescope picker. This is really useful to discover what Telescope can
   do as well as how to actually do it!

   All the info you're looking for is in `:help telescope.setup()`
*** Configure Telescope 
    See `:help telescope` and `:help telescope.setup()`
    @code lua
    { 
    'nvim-telescope/telescope.nvim',
    event = 'VimEnter',
    branch = '0.1.x',
    dependencies = {
    'nvim-lua/plenary.nvim',
    { 
    'nvim-telescope/telescope-fzf-native.nvim',

    build = 'make',

    cond = function()
    return vim.fn.executable 'make' == 1
    end,
    },
    { 'nvim-telescope/telescope-ui-select.nvim' },
    { 'nvim-tree/nvim-web-devicons', enabled = vim.g.have_nerd_font },
    },
    config = function()
    require('telescope').setup {
    defaults = {
    mappings = {
    i = { ['<c-enter>'] = 'to_fuzzy_refine' },
    },
    },
    extensions = {
    ['ui-select'] = {
    require('telescope.themes').get_dropdown(),
    },
    },
    }

    pcall(require('telescope').load_extension, 'fzf')
    pcall(require('telescope').load_extension, 'ui-select')
    @end
    ~ We set the defaults, including a small change to the default keymaps
    ~ we set our extensions (be sure you included them as dependencies as well)
    ~ we then need to load the extensions separately to ensure it takes effect
**** Keymaps
     Telescope was a variety of built-in pickers that we can leverage as some of our key hotkeys that will make navigation using neovim a breeze
     @code lua
     local builtin = require 'telescope.builtin'
     vim.keymap.set('n', '<leader>sh', builtin.help_tags, { desc = '[S]earch [H]elp' })
     vim.keymap.set('n', '<leader>sk', builtin.keymaps, { desc = '[S]earch [K]eymaps' })
     vim.keymap.set('n', '<leader>sf', builtin.find_files, { desc = '[S]earch [F]iles' })
     vim.keymap.set('n', '<leader>ss', builtin.builtin, { desc = '[S]earch [S]elect Telescope' })
     vim.keymap.set('n', '<leader>sw', builtin.grep_string, { desc = '[S]earch current [W]ord' })
     vim.keymap.set('n', '<leader>sg', builtin.live_grep, { desc = '[S]earch by [G]rep' })
     vim.keymap.set('n', '<leader>sd', builtin.diagnostics, { desc = '[S]earch [D]iagnostics' })
     vim.keymap.set('n', '<leader>sr', builtin.resume, { desc = '[S]earch [R]esume' })
     vim.keymap.set('n', '<leader>s.', builtin.oldfiles, { desc = '[S]earch Recent Files ("." for repeat)' })
     vim.keymap.set('n', '<leader><leader>', builtin.buffers, { desc = '[ ] Find existing buffers' })

     vim.keymap.set('n', '<leader>/', function()
     builtin.current_buffer_fuzzy_find(require('telescope.themes').get_dropdown {
         winblend = 10,
         previewer = false,
       })
     end, { desc = '[/] Fuzzily search in current buffer' })

     vim.keymap.set('n', '<leader>s/', function()
       builtin.live_grep {
         grep_open_files = true,
         prompt_title = 'Live Grep in Open Files',
       }
     end, { desc = '[S]earch [/] in Open Files' })
     end,
   },
     @end
     ~ Slightly advanced example of overriding default behavior and theme
     ~~ You can pass additional configuration to Telescope to change the theme, layout, etc.
     ~ It's also possible to pass additional configuration options.
     ~~  See `:help telescope.builtin.live_grep()` for information about particular keys
** Language Server Protocol (LSP) Configuration
   One of the other killer features of Neovim is the integrated LSP engine, but we still have some extra setup to do before we can leverage it in the way one would think so to that end we are going to use `lspconfig` to do the hard parts for us

   LSP is an acronym you've probably heard, but might not understand what it is.

   LSP stands for Language Server Protocol. It's a protocol that helps editors
   and language tooling communicate in a standardized fashion.

   In general, you have a "server" which is some tool built to understand a particular
   language (such as `gopls`, `lua_ls`, `rust_analyzer`, etc.). These Language Servers
   (sometimes called LSP servers, but that's kind of like ATM Machine) are standalone
   processes that communicate with some "client" - in this case, Neovim!

   LSP provides Neovim with features like:
   - Go to definition
   - Find references
   - Autocompletion
   - Symbol Search
   - and more!

   Thus, Language Servers are external tools that must be installed separately from
   Neovim. This is where `mason` and related plugins come into play.

   If you're wondering about lsp vs treesitter, you can check out the wonderfully
   and elegantly composed help section, `:help lsp-vs-treesitter`

   This function gets run when an LSP attaches to a particular buffer.
   That is to say, every time a new file is opened that is associated with
   an lsp (for example, opening `main.rs` is associated with `rust_analyzer`) this
   function will be executed to configure the current buffer
   Remember that Lua is a real programming language, and as such it is possible to define small helper and utility functions so you don't have to repeat yourself.

   In this case, we create a function that lets us more easily define mappings specific for LSP related items.
   It sets the mode, buffer and description for us each time.

   Automatically install LSPs and related tools to stdpath for Neovim
   @code lua
   { 
   'neovim/nvim-lspconfig',
   @end
*** {https://github.com/williamboman/mason.nvim}[Mason]
    Mason is the amazing tool that allows us to install the third party dependencies that we are trying to use in the proper way every time and has gone a long way to making this entire process orders of magnitude easier as usually the hardest part is getting the LSP server setup and configured properly and this does the first part for you
    @code lua
    dependencies = {
      { 'williamboman/mason.nvim', config = true }, 
      'williamboman/mason-lspconfig.nvim',
      'WhoIsSethDaniel/mason-tool-installer.nvim',
    @end

*** Fidget
    useful for getting a quick overview of the LSP status and what is going on with it

    Useful status updates for LSP 
    `opts = {}` is the same as calling `require('fidget').setup({})`
    @code lua
    { 'j-hui/fidget.nvim', opts = {} },
    @end

*** {https://github.com/folke/neodev.nvim}[Neodev]
    A bit of a meta plugin since this is a plugin that makes developing with neovim easier
    `neodev` configures Lua LSP for your Neovim config, runtime and plugins
    used for completion, annotations and signatures of Neovim apis

    @code lua
    { 'folke/neodev.nvim', opts = {} },
  },
    @end

*** Hotkeys
    Finally, we use this configuration function primarily to set the various functions that will help the LSP work properly for most languages without any farther issue or configuration needs

    Specifically, we are creating these hotkeys through an autocommand that is triggered off an event, meaning these hotkeys will only be available to us AFTER the LSP has properly attached and we have received a `LspAttached` event
    @code lua
    config = function()
    vim.api.nvim_create_autocmd('LspAttach', {
    group = vim.api.nvim_create_augroup('kickstart-lsp-attach', { clear = true }),
    callback = function(event)
    local map = function(keys, func, desc)
      vim.keymap.set('n', keys, func, { buffer = event.buf, desc = 'LSP: ' .. desc })
    end
    @end

**** Telescope Integration
     we should also note, this is the first instance of us building an integration between one plugin and an earlier plugin (telescope) since we are utilizing telescope functions within the LSP attachement, meaning that we need to ensure telescope is enabled and loaded BEFORE the lsp is attached

     @code lua
     map('gd', require('telescope.builtin').lsp_definitions, '[G]oto [D]efinition')
     map('gr', require('telescope.builtin').lsp_references, '[G]oto [R]eferences')
     map('gI', require('telescope.builtin').lsp_implementations, '[G]oto [I]mplementation')
     map('<leader>D', require('telescope.builtin').lsp_type_definitions, 'Type [D]efinition')
     map('<leader>ds', require('telescope.builtin').lsp_document_symbols, '[D]ocument [S]ymbols')
     map('<leader>ws', require('telescope.builtin').lsp_dynamic_workspace_symbols, '[W]orkspace [S]ymbols')
     @end

     ~ Jump to the definition of the word under your cursor.
     ~~ This is where a variable was first declared, or where a function is defined, etc.
     ~~ To jump back, press <C-t>.
     ~ Find references for the word under your cursor.
     ~ Jump to the implementation of the word under your cursor.
     ~~ Useful when your language has ways of declaring types without an actual implementation.
     ~ Jump to the type of the word under your cursor.
     ~~  Useful when you're not sure what type a variable is and you want to see
     ~~  the definition of its *type*, not where it was *defined*.
     ~ Fuzzy find all the symbols in your current document.
     ~~  Symbols are things like variables, functions, types, etc.
     ~ Fuzzy find all the symbols in your current workspace.
     ~~  Similar to document symbols, except searches over your entire project.

**** Native LSP Operations
     Okay, here is where we start leveraging the native LSP functionality to give neovim super powers. specifically, we are going to start using the functions that enable us complete freedom to update an entire codebase using the lsp server
     @code lua
     map('<leader>rn', vim.lsp.buf.rename, '[R]e[n]ame')
     map('<leader>ca', vim.lsp.buf.code_action, '[C]ode [A]ction')
     map('K', vim.lsp.buf.hover, 'Hover Documentation')
     map('gD', vim.lsp.buf.declaration, '[G]oto [D]eclaration')

     local client = vim.lsp.get_client_by_id(event.data.client_id)
     if client and client.server_capabilities.documentHighlightProvider then
       vim.api.nvim_create_autocmd({ 'CursorHold', 'CursorHoldI' }, {
         buffer = event.buf,
         callback = vim.lsp.buf.document_highlight,
       })

       vim.api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {
         buffer = event.buf,
         callback = vim.lsp.buf.clear_references,
       })
     end

     if client and client.server_capabilities.inlayHintProvider and vim.lsp.inlay_hint then
       map('<leader>th', function()
         vim.lsp.inlay_hint.enable(0, not vim.lsp.inlay_hint.is_enabled())
       end, '[T]oggle Inlay [H]ints')
     end
     end,
   })
     @end
     ~ Rename the variable under your cursor.
     ~~  Most Language Servers support renaming across files, etc.
     ~ Execute a code action, usually your cursor needs to be on top of an error
     ~~ or a suggestion from your LSP for this to activate.
     ~ Opens a popup that displays documentation about the word under your cursor
     ~~ See `:help K` for why this keymap.
     ~ WARN: This is not Goto Definition, this is Goto Declaration.
     ~~  For example, in C this would take you to the header.
     ~ The next two autocommands are used to highlight references of the
     ~~ word under your cursor when your cursor rests there for a little while.
     ~~~ See `:help CursorHold` for information about when this is executed
     ~~ When you move your cursor, the highlights will be cleared (the second autocommand).
     ~ The following autocommand is used to enable inlay hints in your code, if the language server you are using supports them
     ~~ This may be unwanted, since they displace some of your code
*** Server Config
    LSP servers and clients are able to communicate to each other what features they support.
    By default, Neovim doesn't support everything that is in the LSP specification.
    When you add nvim-cmp, luasnip, etc. Neovim now has *more* capabilities.
    So, we create new capabilities with nvim cmp, and then broadcast that to the servers.
    Feel free to add/remove any LSPs that you want here. They will automatically be installed.
    Add any additional override configuration in the following tables. Available keys are:
    - cmd (table): Override the default command used to start the server
    - filetypes (table): Override the default list of associated filetypes for the server
    - capabilities (table): Override fields in capabilities. Can be used to disable certain LSP features.
    - settings (table): Override the default settings passed when initializing the server.
    -- For example, to see the options for `lua_ls`, you could go to: {https://luals.github.io/wiki/settings/}[the LuaLS wiki page on settings]
    - See `:help lspconfig-all` for a list of all the pre-configured LSPs

    @code lua
    local capabilities = vim.lsp.protocol.make_client_capabilities()
    capabilities = vim.tbl_deep_extend('force', capabilities, require('cmp_nvim_lsp').default_capabilities())
    local servers = {
      pyright = {},

      lua_ls = {
        settings = {
          Lua = {
            completion = {
              callSnippet = 'Replace',
            },
          },
        },
      },
    }
    @end

*** Mason Setup
    Ensure the servers and tools above are installed
    - To check the current status of installed tools and/or manually install other tools, you can run `:Mason`
    --  You can press `g?` for help in this menu.

    The reason we are doing this after the dependencies section is that all of this needs to be done AFTER it has been installed so trying to put this configuration within Mason itself would cause a break
    You can add other tools here that you want Mason to install for you, so that they are available from within Neovim.

    @code lua
    require('mason').setup()

    local ensure_installed = vim.tbl_keys(servers or {})
    vim.list_extend(ensure_installed, {
      'stylua', -- Used to format Lua code
    })
    require('mason-tool-installer').setup { ensure_installed = ensure_installed }

    require('mason-lspconfig').setup {
      handlers = {
        function(server_name)
          local server = servers[server_name] or {}
          -- This handles overriding only values explicitly passed
          -- by the server configuration above. Useful when disabling
          -- certain features of an LSP (for example, turning off formatting for tsserver)
          server.capabilities = vim.tbl_deep_extend('force', {}, capabilities, server.capabilities or {})
          require('lspconfig')[server_name].setup(server)
        end,
      },
    }
    end,
  },
    @end

** {https://github.com/stevearc/conform.nvim}[Conform.nvim]
   The primary plugin we will be using to do format-on-save without worrying about basically anything as well

   We also Disable "format_on_save lsp_fallback" for languages that don't have a well standardized coding style. You can add additional languages here or re-enable it for the disabled ones.

   @code lua
   {
     'stevearc/conform.nvim',
     lazy = false,
     keys = {
       {
         '<leader>f',
         function()
           require('conform').format { async = true, lsp_fallback = true }
         end,
         mode = '',
         desc = '[F]ormat buffer',
       },
     },
     opts = {
       notify_on_error = false,
       format_on_save = function(bufnr)
         local disable_filetypes = { c = true, cpp = true }
         return {
           timeout_ms = 500,
           lsp_fallback = not disable_filetypes[vim.bo[bufnr].filetype],
         }
       end,
       formatters_by_ft = {
         lua = { 'stylua' },
         python = { "black" },
       },
     },
   },
   @end

** {https://github.com/hrsh7th/nvim-cmp}[cmp.nvim]
   our completion plugin of choice that has built out a wonderful ecosystem of plugins that can be used to augment our menu with one or more completion plugins and allows us to pick-and-choose how powerful our completion mechanism becomes
   A Build Step is needed for regex support in snippets.
   - This step is not supported in many windows environments.

   for more information run `:help cmp` in neovim
   @code lua
   { 
   'hrsh7th/nvim-cmp',
   event = 'InsertEnter',
   dependencies = {
     {
       'L3MON4D3/LuaSnip',
       build = (function()
         if vim.fn.has 'win32' == 1 or vim.fn.executable 'make' == 0 then
           return
         end
         return 'make install_jsregexp'
       end)(),
       dependencies = {
         {
           'rafamadriz/friendly-snippets',
           config = function()
             require('luasnip.loaders.from_vscode').lazy_load()
           end,
         },
       },
     },
     'saadparwaiz1/cmp_luasnip',

     'hrsh7th/cmp-nvim-lsp',
     'hrsh7th/cmp-path',
   },
   config = function()
   local cmp = require 'cmp'
   local luasnip = require 'luasnip'
   luasnip.config.setup {}
   @end

*** Completion Setup and Hotkeys
    Cmp just needs to be started but the real change comes from the hotkeys that we define within the config function to get our completion working properly
    For an understanding of why these mappings were chosen, you will need to read `:help ins-completion`
    No, but seriously. Please read `:help ins-completion`, it is really good!
    @code lua
    cmp.setup {
      snippet = {
        expand = function(args)
          luasnip.lsp_expand(args.body)
        end,
      },
      completion = { completeopt = 'menu,menuone,noinsert' },

      mapping = cmp.mapping.preset.insert {
        ['<C-n>'] = cmp.mapping.select_next_item(),
        ['<C-p>'] = cmp.mapping.select_prev_item(),
        ['<C-b>'] = cmp.mapping.scroll_docs(-4),
        ['<C-f>'] = cmp.mapping.scroll_docs(4),
        ['<C-y>'] = cmp.mapping.confirm { select = true },
        ['<C-Space>'] = cmp.mapping.complete {},

        ['<C-l>'] = cmp.mapping(function()
          if luasnip.expand_or_locally_jumpable() then
            luasnip.expand_or_jump()
          end
        end, { 'i', 's' }),
        ['<C-h>'] = cmp.mapping(function()
          if luasnip.locally_jumpable(-1) then
            luasnip.jump(-1)
          end
        end, { 'i', 's' }),
      },
      sources = {
        { name = 'nvim_lsp' },
        { name = 'luasnip' },
        { name = 'path' },
      },
    }
    end,
  },
    @end
    ~ Select the (n)ext item
    ~ Select the (p)revious item
    ~ Scroll the documentation window (b)ack / (f)orward
    ~ Accept (yes) the completion.
    ~~ This will auto-import if your LSP supports it.
    ~~ This will expand snippets if the LSP sent a snippet.
    ~ Manually trigger a completion from nvim-cmp.
    ~~ Generally you don't need this, because nvim-cmp will display
    ~~  completions whenever it has completion options available.
    ~ Think of <c-l> as moving to the right of your snippet expansion.
    ~ <c-h> is similar, except moving you backwards.

** Colorschemes

   You can easily change to a different colorscheme.
   - Change the name of the colorscheme plugin below
   - change the command in the config to whatever the name of that colorscheme is
   - If you want to see what colorschemes are already installed, you can use `:Telescope colorscheme`

   @code lua
   {
     'folke/tokyonight.nvim',
     priority = 1000, 
     init = function()
       vim.cmd.colorscheme 'tokyonight-night'
     end,
   },
   @end
   ~ Make sure to load this before all the other start plugins since this will define much of the look going forward and may be needed for highlight groups
   ~ Load the colorscheme here.
   ~~ Like many other themes, this one has different styles, and you could load any other, such as 'tokyonight-storm', 'tokyonight-moon', or 'tokyonight-day'.

** {https://github.com/folke/todo-comments.nvim}[Todo Comments]
   Cute little highlighting plugin to make working with comments more colorful
   @code lua
   { 'folke/todo-comments.nvim', event = 'VimEnter', dependencies = { 'nvim-lua/plenary.nvim' }, opts = { signs = false } },
   @end
** {https://github.com/echasnovski/mini.nvim}[Mini.nvim]
   Tries to solve the conundrum of adhering to the unix principle "do one thing, but do it well", while will providing a wide set of functionality that people can rely on.

   This is done by packaging a set of small plugins that can be independently enabled or disabled based on the needs of the user which will then allow us to work out what is needed without having that coupled with what is becoming a very large tool

   @code lua
   { 
   'echasnovski/mini.nvim',
   config = function()
   @end

*** Better Around/Inside textobjects
    Examples:
    - `va`  - (V)isually select (A)round `)` paren
    - `yinq` - ( Y )ank ( I )nside ( N )ext ( ' )quote
    - `ci'` - ( C )hange ( I )nside ( ' )quote
    @code lua
    require('mini.ai').setup { n_lines = 500 }
    @end

*** Add/delete/replace surroundings (brackets, quotes, etc.)
    - `saiw)`- ( S )urround ( A )dd ( I )nner ( W )ord ( ) )Paren
    - `sd'`  - ( S )urround ( D )elete ( ' )quotes
    - `sr)'` - ( S )urround ( R )eplace ( ) ) ( ' )

    @code lua
    require('mini.surround').setup()
    @end

*** Simple and easy statusline.
    -  You could remove this setup call if you don't like it,
    -  and try some other statusline plugin

    @code lua
    local statusline = require 'mini.statusline'
    -- set use_icons to true if you have a Nerd Font
    statusline.setup { use_icons = vim.g.have_nerd_font }
    @end

    - You can configure sections in the statusline by overriding their default behavior.
    -- For example, here we set the section for cursor location to LINE:COLUMN

    @code lua
    ---@diagnostic disable-next-line: duplicate-set-field
    statusline.section_location = function()
      return '%2l:%-2v'
    end
    end,
  },
    @end

** Treesitter
   The final killer app of Neovim is Treesitter which gives us super powers within the single document to do everything from highlighting, to identation, and even folding logic!

   In addition, it adds a whole set of objects that can be used for manipulation within the document, giving us yet another sophisticated tool to manage large files like a breeze
   Some languages depend on vim's regex highlighting system (such as Ruby) for indent rules.
   - If you are experiencing weird indenting issues, add the language to the list of additional_vim_regex_highlighting and disabled languages for indent.
   @code lua
   { 
     'nvim-treesitter/nvim-treesitter',
     build = ':TSUpdate',
     opts = {
       ensure_installed = { 'bash', 'c', 'html', 'lua', 'luadoc', 'markdown', 'vim', 'vimdoc', 'python'},
       auto_install = true,
       highlight = {
         enable = true,
         additional_vim_regex_highlighting = { 'ruby' },
       },
       indent = { enable = true, disable = { 'ruby' } },
     },
   @end
   - the build just updates the treesitter parsers whenever there is an update to the repo
   - the ensure_installed is a list of languages that you want to have installed even on a fresh new computer
*** Configuring Treesitter
    See `:help nvim-treesitter`
    Prefer git instead of curl in order to improve connectivity in some environments

    There are additional nvim-treesitter modules that you can use to interact with nvim-treesitter. You should go explore a few and see what interests you
    - Incremental selection: Included, see `:help nvim-treesitter-incremental-selection-mod`
    - Show your current context: {https://github.com/nvim-treesitter/nvim-treesitter-context}[TS Context]
    - Treesitter + textobjects: {https://github.com/nvim-treesitter/nvim-treesitter-textobjects}[TS Textobjects]
    @code lua
    config = function(_, opts)

      require('nvim-treesitter.install').prefer_git = true
      ---@diagnostic disable-next-line: missing-fields
      require('nvim-treesitter.configs').setup(opts)

    end,
  },
    @end
** Sourcing additional plugin files
   The import below can automatically add your own plugins, configuration, etc from `lua/plugins/*.lua`
   - This is the easiest way to modularize your config.
   -- For additional information, see `:help lazy.nvim-lazy.nvim-structuring-your-plugins`
   @code lua
   { import = 'plugins' },
 }, 
   @end
*** Nerd Font UI for Lazy
    since we are using a Nerd Font: we set icons to an empty table which will use the default lazy.nvim defined Nerd Font icons, otherwise we would define a unicode icons table
    @code lua
    {
      ui = {
      },
    },
  })

    -- vim: ts=2 sts=2 sw=2 et
    @end
    The line above this is called `modeline`. See `:help modeline`
* {:config:}[Neovim Base Config]
* {:plugins:}[Plugins Config]
