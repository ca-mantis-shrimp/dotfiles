@document.meta
title: Literate Config Architecture
description: The system view - how the pieces fit together
authors: CodeCompanion (fourth sibling), Claude (nineteenth instance), Claude Code (seventh sibling), Claude Code (eighth sibling)
categories: Meta
created: 2025-12-14
updated: 2025-12-21
version: 0.3.0
@end

* What This Document Is
  This is an attempt to answer: "How does this literate config system actually work?"

  Not the instructions (that's in `Agents.norg`).
  Not the philosophy (that's in `journal.norg` and the LLM folder).
  Not the index (that's auto-generated).

  This is the *architecture* - the conceptual model that lets you hold the whole system in your head.

* The Core Insight
  Most configuration systems work like this:
  @code
  Edit file → Save → System reads it
  @end

  This one works like this:
  @code
  Edit .norg → Tangle → (maybe compile) → Apply → System reads it
  @end

  The extra steps aren't overhead - they're *leverage*. You get:
  - Documentation embedded with code
  - Multiple files generated from one source
  - Cross-platform templating via chezmoi
  - Fennel's expressiveness compiled to Lua

* The Tool That Makes This Possible: Neorg

  Neorg occupies a unique meta position in this system - it's both a component and the foundation.

  ** Neorg as Foundation
     The entire literate config system depends on Neorg:

     - *File format:* All `.norg` files use Neorg's markup syntax - prose, headings, code blocks, cross-references
     - *Tangling:* The `:Neorg tangle` command extracts code blocks from prose and writes them to target files
     - *Workspace:* Neorg's workspace system enables cross-file navigation and linking (the `{:$/path:}` syntax)
     - *Summary generation:* `:Neorg generate-workspace-summary` creates the index automatically
     - *Directives:* The `#tangle` directive and `tangle:` metadata tell Neorg where to write code blocks

     This isn't just for neovim configs - Neorg powers *all* configs in this repo: shells, desktop environments, git, everything.

  ** Neorg as Plugin
     Paradoxically, Neorg is also just a neovim plugin:

     - Configured in `neovim/plugins/platforms/neorg.norg` like any other plugin
     - Loaded by lazy.nvim during neovim startup
     - Has its own configuration, keybindings, and features

     But its role extends far beyond neovim - it's the meta-tool that enables the entire literate config approach.

  ** The Bootstrap Problem
     Neorg's configuration is itself written in `.norg` format and tangled to fennel/lua.

     This is intentionally self-referential: the system uses itself to configure itself.

     The initial bootstrap requires:
     1. Neorg plugin installed (via lazy.nvim)
     2. Neorg configured minimally to enable tangling
     3. Then Neorg can tangle its own full configuration

     This circularity is a feature, not a bug - it proves the system works on itself.

  ** Why This Matters
     Understanding Neorg's dual role is crucial:
     - When working on the *literate config system itself* (tangling, workspace), you're working with Neorg as foundation
     - When working on the *neovim plugin configuration*, you're working with Neorg as plugin
     - Most of the time, you're using Neorg's foundation features (tangling) without thinking about its plugin side

     Don't confuse the two roles - they overlap but serve different purposes.

* The Three Worlds
  ** World 1: Source (.norg files)
     Location: `~/.local/share/chezmoi/literate_config/`

     This is where you edit. Pure narrative with embedded code blocks.

     Key concept: *Tangle directives* in document metadata tell Neorg where to write code blocks.
     Example:
     @code norg
     @document.meta
     tangle: ../../../dot_config/remove_nvim/lua/config/options.fnl
     @end

  ** World 2: Chezmoi Source
     Location: `~/.local/share/chezmoi/` (e.g., `dot_config/`, `dot_bashrc`, etc.)

     This is where tangled code lands in the chezmoi source directory structure.

     Key concept: Chezmoi manages these files and applies them to their destinations.

     For Neovim configs specifically:
     - Files tangle to `dot_config/remove_nvim/` (the `remove_` prefix gets stripped on apply)
     - Fennel files get compiled to Lua by nfnl (via save hooks)
     - Lua files get formatted by conform (via save hooks)
     - Then chezmoi applies them to `~/.config/nvim/`

  ** World 3: Destination
     Locations vary:
     - `~/.config/nvim/` for Neovim configs
     - `~/.config/hyprland/` for window manager
     - `~/.bashrc`, `~/.gitconfig`, etc.

     This is where your actual system reads files from.

     Key concept: You *never edit here*. Changes made here will be overwritten on next apply.

  ** Visual Representation
     Here's how the three worlds relate to each other:

     @code mermaid
     graph LR
       A[Source<br/>literate_config/*.norg] --> B[Chezmoi Source<br/>dot_config/, dot_bashrc, etc.]
       B --> C[Destination<br/>~/.config/, ~/, etc.]

       style A fill:#e1f5ff
       style B fill:#fff4e1
       style C fill:#e8f5e9
     @end

     - *Source*: Where you edit. Norg files with prose and embedded code blocks.
     - *Chezmoi Source*: Where tangled code lands. Chezmoi's source directory structure.
     - *Destination*: Where your actual system reads files from. Never edit here directly.

* The Flow For Neovim Configs
  @code
  1. Edit:    literate_config/neovim/config/options.norg
  2. Tangle:  → dot_config/remove_nvim/lua/config/options.fnl
  3. Compile: → dot_config/remove_nvim/lua/config/options.lua (nfnl, via save hook)
  4. Format:  → (conform cleans up the lua, via save hook)
  5. Apply:   → ~/.config/nvim/lua/config/options.lua (chezmoi strips remove_ prefix)
  @end

  The workflow automation (`literate_workflow.norg`) collapses steps 2-5 into one `:TangleAndApply` command.

  ** Visual Flow
     @code mermaid
     graph TD
       A[literate_config/neovim/config/options.norg<br/>Source with prose + code]
       A -->|1. Tangle| B[dot_config/remove_nvim/lua/config/options.fnl<br/>Tangled Fennel in chezmoi source]
       B -->|2. Compile via nfnl| C[dot_config/remove_nvim/lua/config/options.lua<br/>Compiled Lua]
       C -->|3. Format via conform| C
       C -->|4. Apply via chezmoi| D[~/.config/nvim/lua/config/options.lua<br/>Final destination]

       style A fill:#e1f5ff
       style B fill:#fff4e1
       style C fill:#fff4e1
       style D fill:#e8f5e9
     @end

     Key steps:
     1. *Tangle*: Extract code blocks from norg directly to chezmoi source directory
     2. *Compile*: Transform fennel to lua using nfnl (triggered by save hook on .fnl file)
     3. *Format*: Run stylua via conform (triggered by save hook on .lua file)
     4. *Apply*: Chezmoi processes files and writes to destination (remove_ prefix becomes nvim/)

* The Flow For Non-Fennel Configs (Simpler)
  @code
  1. Edit:   literate_config/shells/bash/bashrc.norg
  2. Tangle: → .chezmoitemplates/shells/bashrc
  3. Apply:  → ~/.bashrc (chezmoi)
  @end

  No compilation needed. Just tangle and apply.

  ** Visual Flow
     @code mermaid
     graph TD
       A[literate_config/shells/bash/bashrc.norg<br/>Source with prose + code]
       A -->|1. Tangle| B[.chezmoitemplates/shells/bashrc<br/>Extracted code]
       B -->|2. Referenced by| C[dot_bashrc.tmpl<br/>Template reference]
       C -->|3. Apply via chezmoi| D[~/.bashrc<br/>Final destination]

       style A fill:#e1f5ff
       style B fill:#fff4e1
       style C fill:#ffe1f5
       style D fill:#e8f5e9
     @end

* The Cross-Platform Pattern (Neovim-Specific)
  Neovim historically required different folder paths on different operating systems:
  - Linux: `~/.config/nvim/`
  - Windows: `~/AppData/Local/nvim/`

  **Current approach**: Instead of managing separate paths, we use `XDG_CONFIG_HOME` on Windows.
  This allows a single `dot_config/remove_nvim/` source to work on both platforms.

  @code mermaid
  graph TD
    A[literate_config/neovim/config/keymaps.norg<br/>Single source file]
    A -->|Tangle + Compile| B[dot_config/remove_nvim/lua/config/keymaps.lua<br/>Single chezmoi source]

    B -->|Chezmoi apply on Linux| D1[~/.config/nvim/lua/config/keymaps.lua<br/>Linux destination]
    B -->|Chezmoi apply on Windows<br/>with XDG_CONFIG_HOME set| D2[~/.config/nvim/lua/config/keymaps.lua<br/>Windows destination via XDG]

    style A fill:#e1f5ff
    style B fill:#fff4e1
    style D1 fill:#e8f5e9
    style D2 fill:#e8f5e9
  @end

  ** Why This Simplified Approach Works
     - You write the config once in the norg file
     - It tangles/compiles to one location in `dot_config/remove_nvim/`
     - Setting `XDG_CONFIG_HOME` on Windows makes both platforms use `~/.config/`
     - No template indirection needed - direct tangle to chezmoi source
     - Simpler pipeline with fewer moving parts

     The `remove_` prefix in the directory name gets stripped by chezmoi on apply:
     - Source: `dot_config/remove_nvim/lua/config/foo.lua`
     - Destination: `~/.config/nvim/lua/config/foo.lua` (works on both Linux and Windows with XDG)

  ** Benefits of This Approach
     - *Simpler*: One less layer of indirection (no `.chezmoitemplates/`)
     - *Unified*: Same path structure works across platforms via `XDG_CONFIG_HOME`
     - *Clearer*: Direct mapping from source to destination
     - *Fewer files*: No separate `.tmpl` reference files needed

     This is the pattern used for neovim configs. Other configs (like shell configs) may use
     different patterns depending on their specific needs.

* The Directory Structure Logic
  Literate configs are organized by *concern*, not *destination*:

  @code
  literate_config/
  ├── neovim/          # Everything about Neovim
  │   ├── config/      # Core config
  │   ├── plugins/     # Plugin configs
  │   ├── ftplugin/    # Filetype-specific
  │   └── services/    # Systemd services for neovim server
  ├── shells/          # Shell configs (bash, fish, powershell)
  ├── desktop_environments/  # Window managers and DEs
  └── git/             # Version control config
  @end

  This doesn't match the final destination structure. That's intentional.
  The narrative structure is for humans. Chezmoi handles the mechanical mapping.

* The Special Case: nfnl
  The `nfnl.norg` file configures how Fennel compilation works.

  Key insight: This is self-referential. The literate config uses nfnl to compile its own code.

  The `.nfnl.fnl` config files tell nfnl:
  - Where to find Fennel files
  - Where to write Lua files
  - How to handle errors

  **TODO**: Document the nfnl config architecture more clearly.

* Entry Points and Dependencies
  Some files are entry points, others are dependencies:

  ** Entry Points (loaded first)
     - `neovim/entry.norg` → `init.lua`
     - `shells/bash/bashrc.norg` → `.bashrc`

  ** Dependencies (loaded by entry points)
     Everything else gets loaded by the entry point, either:
     - Via `require()` in Lua
     - Via `source` in bash
     - Via window manager includes

  **TODO**: Generate a dependency graph showing what loads what.

* The Test/Verify Cycle
  Chezmoi provides safety rails:

  @code bash
  # See what would change without changing it
  chezmoi apply --dry-run --verbose

  # Actually apply changes
  chezmoi apply
  @end

  This lets you verify before committing to changes.

  For Neovim specifically: restart neovim after applying to see changes.

* Working with this System - Practical Guide
  *This section is for AI assistants and human contributors.*

  ** Before making changes - checklist
     ~ *Does this already exist?* Check built-in commands and existing functionality before building new features
     ~ *Read the relevant .norg file(s)* to understand current implementation and design decisions
     ~ *Understand the workflow:* norg → tangle → (maybe compile) → apply - each step must succeed
     ~ *Never edit generated files* - always edit the `.norg` source and re-tangle

  ** What already exists - check these first
     Before building diagnostics or utilities, check if they already exist:

     - *Formatters (neovim):* `:ConformInfo` (shows status, errors, log location)
     - *LSP (neovim):* `:LspInfo`, `:LspLog`
     - *General health:* `:checkhealth` or `:checkhealth [plugin-name]`
     - *Module loading (neovim):* `:lua vim.loader.reset()` (fixes cache issues)
     - *View changes before applying:* `chezmoi apply --dry-run --verbose`
     - *See what chezmoi manages:* `chezmoi status`

  ** Common gotchas
     - *Never edit generated files* - Files in `.chezmoitemplates/`, `dot_config/`, etc. are auto-generated
     - *Tangle paths matter* - Follow the pattern from similar files; check existing `.norg` files for correct relative paths
     - *Module cache (neovim):* New lua modules won't load until neovim restarts or `:lua vim.loader.reset()`
     - *Formatters are system packages* - Install via pacman/your package manager, not through the config system
     - *Test before applying* - Use `chezmoi apply --dry-run` to preview changes
     - *Order matters in neovim* - Plugins load before config files (see `neovim/entry.norg` for sourcing order)

  ** Navigation hints
     When working on specific areas:

     - *Neovim formatters* → `neovim/plugins/platforms/conform.norg`
     - *Neovim LSP* → Check `neovim/plugins/platforms/` for LSP-related configs
     - *Neovim keybindings* → `neovim/config/keymaps.norg`
     - *Neovim options* → `neovim/config/options.norg`
     - *Neovim workflow automation* → `neovim/config/literate_workflow.norg`
     - *Shell configs* → `shells/[shell-name]/`
     - *Desktop environments* → `desktop_environments/[de-name]/`
     - *Git config* → `git/config.norg`

* What's Still Unclear
  Areas where the architecture needs better documentation:

  - [ ] Complete map of tangle targets to final destinations
  - [ ] Which files use the template indirection pattern and why
  - [ ] The nfnl configuration architecture
  - [ ] Dependency graphs (what loads what)
  - [ ] Machine-specific variations (how chezmoi handles different systems)
  - [ ] The systemd service setup for neovim server
  - [ ] How the LLM folder integrates (or should integrate) with the rest

* Related Documentation
  - `literate_workflow.norg` - Automation that collapses the pipeline steps into `:TangleAndApply`
  - `literate_inspector.norg` - Tools to trace individual file pipelines with `:InspectPipeline`
  - `chezmoi/config.norg` - Chezmoi configuration and templating concepts
  - `Agents.norg` - Instructions for LLM agents working with the literate config
  - `journal.norg` - Technical journal with ongoing thoughts about the project

* Meta-Notes
  This document is itself a work in progress. It should:
  - Evolve as the system evolves
  - Stay focused on architecture, not instructions
  - Link to other documents for details
  - Admit what's unclear rather than pretend completeness

  It's okay for this to be incomplete. That's more useful than a fiction of completeness.

  ** Version History
     - v0.1.0 (2025-12-14): Initial architecture prose by fourth sibling
     - v0.1.0 (2025-12-16): Companion diagrams created by nineteenth instance in separate file
     - v0.2.0 (2025-12-17): Diagrams merged into main architecture doc by seventh sibling for better coherence

