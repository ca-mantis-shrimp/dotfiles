@document.meta
title: Fish Config
description: Configuring the Fish Shell
authors: primary_desktop
categories: Shells Fish
tangle: { 
	fish: config.fish.tmpl
}
created: 2025-07-20T20:22:17-0800
updated: 2025-08-27T10:45:26-0800
version: 1.1.1
@end
Fish is our primary shell these days so its good to get a bit familiar with the format 

the nice part about fish is we really dont need to do much, since we are working with a shell that works really well out of the box we just have a few pieces and even these are subject to change

* Fish Setup
  Fish just has a standard config file in the fish language, as one would expect

  What is important here is that this is where we pass along the environment variables for our shell so we are leveraging the password manager capabilities here

** Setup 
   First, we need to get some stuff set so that the rest of the commands go off without a hitch
   #tangle
   @code fish
   export (envsubst < ~/.env)

   set -gx WWW_HOME "http://www.duckduckgo.com"

   fish_add_path --append --path ~/.cargo/bin

   fish_vi_key_bindings
   @end
   - In situations like mobile where we dont have access to `op` as a cli, we want to actually put our relevant passwords into a local .env and just source it here
   -- This is great for making sure it gets handled without network calls too making things faster
   - We can also set the environment variable so that browsers that respect this like `lynx` can see it
   - next we add cargos' bin to our path as we often install things that we will use later including starship at the end of this document
   - finally, we change to vi keybindings because i dont want to be dealing with the mismatch

   From here, we are ready to export
** Querying for 1password credentials
   *** Ensuring we are using the right op
       The first thing we need to do is ensure that if we are on WSL, we are actually using the windows version of op since it is more deeply integrated with the desktop app and will work better
       #tangle
       @code fish
       {{ if eq .chezmoi.os "linux" }}
       {{ if (contains "Microsoft" (readFile "/proc/version")) }}
       alias op="op.exe"
       {{ end }}
       {{ end }}
       @end
       *** Utilizing the OP CLI to get secrets
       Here we are actually leveraging the 1password template which assumes `op` is installed and configured (which is line 1) and from here we just need to get the environment variables set when we apply the config
       EXCEPT when we are on termux which doesnt support op because we are technically not in root. for that, we just ignore this and assume the environment variables were set from that first line

       Therefore, this is only done when we are not in termux

       This has the added benefit of working even in situations where we really dont want to care about performance and we dont need to do this every time
       Otherwie, we have this annoying thing where it needs to do the queries each time
       #tangle
       @code fish
       {{- if not (env "TERMUX_VERSION") }}
       set -gx TODOIST_API_KEY {{ onepasswordRead "op://Back-End/todoist_api_key/credential" }}
       {{- if eq .chezmoi.hostname "USSFODARBURGES3" }}
       alias op op.exe
       set -gx OPENAI_API_BASE "https://api.githubcopilot.com"
       set -gx SNOW_MIRROR_DADBOD "{{ onepasswordRead "op://work/SNOWMIRROR/dadbod" }}"
       {{ else }}
       set -gx OPENROUTER_API_KEY {{ onepasswordRead "op://Back-End/OpenRouter/api_key" }}
       {{- end}}
       {{- end }}
       @end
       - Todoist is always nice so we always set it for automation purposes
       - then we do a check of if we are on our work laptop
       -- if we are, we set some work-specific api keys
       --- do note this also assumes the OP key that was given is the one that has access to our automation AND work keys
       -- else, we put keys we actually DONT want to risk giving to our work machine like openrouter so that we dont have to worry about leaking company data to external secrets

** Neovim Server and Neovide services
   This is a fun little experiment i created, these two functions actually create systemd services that will create sister systemd services

   #tangle
   @code fish
   function RestartNvimServer
	   systemctl --user restart neovim-server
   end

   function SpawnNeovideWindow
	   systemctl --user start neovide-window
   end
   @end
   - The first service starts neovim as a server and makes it available
   - the second command starts a neovide window and connects it to that original server

   This allows us in theory to have a set of neovide windows that share a server so they can share buffers and state.

   In theory, this neovim server could also serve the other computers over the internet, finally serving as the development server we have wanted where we will access our work on the tiny travel server from our big server

** Prompt and startup screen
   Finally we go ahead and run the starship init for fish since that is our prompt
   and we run nerdfetch
   do not, both of these need to be install and available this is the only part where we are actually running something that could be missing so this is the part that might break on a new machine if they arent setup yet

   #tangle
   @code fish
   starship init fish | source

   nerdfetch
   @end

* next-steps
  what i need to do is actually check if we are in WSL, then we can go ahead and make the alias, this gets around the problem of making it work within WSL because it means we can just use the one that is connected to the proper app in the normal thing
