@document.meta
title: Fish Config
description: Configuring the Fish Shell
authors: primary_desktop
categories: Shells Fish
tangle: ../../../dot_config/fish/config.fish.tmpl
created: 2025-07-20T20:22:17-0800
updated: 2025-11-16T21:39:53-0800
version: 1.1.1
@end
Fish is our primary shell these days so its good to get a bit familiar with the format 

the nice part about fish is we really dont need to do much, since we are working with a shell that works really well out of the box we just have a few pieces and even these are subject to change

* Fish Setup
  Fish just has a standard config file in the fish language, as one would expect

  What is important here is that this is where we pass along the environment variables for our shell so we are leveraging the password manager capabilities here

** Setup 
   First, we need to get some stuff set so that the rest of the commands go off without a hitch
   #tangle
   @code fish
   export (envsubst < ~/.env)

   set -gx WWW_HOME "http://www.duckduckgo.com"
   set -gx EDITOR "nvim"
   set -gx MANPAGER "nvim +Man!"

   fish_add_path --append --path ~/.cargo/bin
   fish_add_path --append --path ~/.local/bin

   set -gx npm_config_prefix "$HOME/.local"
   fish_vi_key_bindings
   @end
   - In situations like mobile where we dont have access to `op` as a cli, we want to actually put our relevant passwords into a local .env and just source it here
   -- This is great for making sure it gets handled without network calls too making things faster
   - We can also set the environment variable so that browsers that respect this like `lynx` can see it
   - we set neovim as our `EDITOR` since it is
   - interestingly, we also use neovim as our pager by setting the `MANPAGER` variable to the man command in neovim
   - next we add cargos' bin to our path as we often install things that we will use later including starship at the end of this document
   - we also add npm stuff installed locally
   - finally, we change to vi keybindings because i dont want to be dealing with the mismatch


   From here, we are ready to export
** Querying for 1password credentials
*** Ensuring we are using the right op
    The first thing we need to do is ensure that if we are on WSL, we are actually using the windows version of op since it is more deeply integrated with the desktop app and will work better
    #tangle
    @code fish
    {{ if eq .chezmoi.os "linux" }}
    {{ if (contains "Microsoft" .chezmoi.kernel.osrelease) }}
    alias op="op.exe"
    {{ end }}
    {{ end }}
    @end
** Neovim Server and Neovide services
   This is a fun little experiment i created, these two functions actually create systemd services that will create sister systemd services

   #tangle
   @code fish
   function RestartNvimServer
	   systemctl --user restart neovim-server
   end

   function SpawnNeovideWindow
	   systemctl --user start neovide-client
   end
   @end
   - The first service starts neovim as a server and makes it available
   - the second command starts a neovide window and connects it to that original server

   This allows us in theory to have a set of neovide windows that share a server so they can share buffers and state.

   In theory, this neovim server could also serve the other computers over the internet, finally serving as the development server we have wanted where we will access our work on the tiny travel server from our big server

** Prompt and startup screen
   Finally we go ahead and run the starship init for fish since that is our prompt
   and we run nerdfetch
   do not, both of these need to be install and available this is the only part where we are actually running something that could be missing so this is the part that might break on a new machine if they arent setup yet

   #tangle
   @code fish
   starship init fish | source

   nerdfetch
   @end

* credentials
  it is assumed that credentials are handled either at runtime, or they are actually configured on a per-app configuration basis.

  This ensures that configuration for things like `claude`, `copilot` and `gemini` get what they need WITHOUT using our work in this format such that we cant get it working without op.

  This kinda undoes the problems ive been having with the local phone config too since we have removed the hard dependency on `op` and are just going to leverage native completion.

  still dont know but we will see how it goes then it comes down to it

  for the usecases be sure to review:
  - `systemd-creds` for service credentials
  - `op run` for running applications live
  - op shell plugins that will allow us to generate configs at runtime and erase them later

  with these we should be able to work WITHOUT having our secure keys in the environment just lying around
